---
title: Games101 8.Shading 2(Shading, Pipeline and Texture Mapping)
---

## Blinn-Phong Reflectance Model

### Specular Term

从经验上来看，什么时候我们能看到高光呢？
![Alt text](image.png)

- 首先平面应该比较光滑
- 然后它的反射方向非常接近镜面反射的方向
- 最后是观察方向和反射方向足够接近

![Alt text](image-1.png)

- Blinn-Phong Model 中有一个很巧妙的做法，用半程向量（观察向量和入射方向的角平分线方向）和法线向量接近去表示观察方向和反射方向接近。
- 直接用观察方向和反射方向去算也可以，这个模型叫做 Phong Reflectance Model，但是计算量更大一些。
- 仍然是用点乘去衡量两个向量是否接近
- 用 ks 去表示镜面反射系数，通常高光是白色
- 最后我们用 p 去调整高光的大小

![Alt text](image-2.png)

- 向量之间夹角余弦确实能体现两个方向之间是不是足够接近，但是这个容忍度太高了。甚至在 45 度的时候仍然有一个较大的值。
- 通常 p 的值在 100-200 之间，64 还不够，通常高光是 3-5 度之外才看不到的。

不同系数下的高光效果：
![Alt text](image-3.png)

### Ambient Term

![Alt text](image-4.png)

- 环境光照来自于其他四面八方的间接光，在 Blind-Phong Model 中，我们做了一个假设，认为每个点接收到的环境光都是相同的，这个强度叫做 ia，环境光的颜色叫做 ka。
- 环境光不考虑光源的方向，也不考虑观察方向。ia 和 ka 都是常数。（当然这个假设在物理上肯定不成立，需要用到非常精细的计算，后面全局光照会讲到）

### Blinn-Phong Reflectance Model

最后我们三个部分加起来就是 Blinn-Phong Reflectance Model：
![Alt text](image-5.png)
我们遍历所有 shading point，然后对每个点做一次着色，然后就能看到整个场景。

### Questions

- 如果一个点凹下去，环境光应该暗一些？Blinn-Phong Model 处理不了这个问题。
- 磨砂表面是否没有高光？不完全是，取决于磨的程度。
- Diffuse 不考虑 point view 的距离？不考虑，也不考虑物体到观察点的距离造成的能量损失。

## Shading Frequencies

### 00:20:31,93

![00-20-31](tmp/00-20-31.jpg)

没问题

那么呃这一部分我们要说的就是着色频率

然后着色频率是什么意思

就是就是大家看这么几个例子就可以看到了哈

### 00:20:40,3

![00-20-40](tmp/00-20-40.jpg)

大家可以看这这三个球

这三个球呢首先他们拥有完全相同的这个几何形状

就是说它们的几何表示在空间中是一模一样的

没有任何问题

从哪儿可以看得出来呢

从这个球的边界对吧

这三个球虽然大家看上去它这个这个颜色什么东西长得各不相同

但从边界上就可以这个暴露这么一个信息啊

这三个这个球其实他们模型用的一模一样

然后那为什么说我这个着色了之后

它的这个结果各不相同呢

那这时候就是我们所说的这个着色频率

所谓着色频率

这里给大家说一下

就是说啊这个着色我要把它应用在哪些点上

咱不是说着色是应用在一个着色点上吗

确定 point 的对吧

那如果说我把这个着色应用在一个这个面上

比如说这里看到的不是三角形面

就是把四边形面那一个面

它是假如说它是个平面

然后呢我就知道这个平面它有一个这个固定的法线

然后呢我这个求出来它的这个这个呃这个 shading 的结果是多少

然后我认为整个平面都长这个颜色好

那也就是说一个平面我只用做一次协定啊

那我得到的就是这么一个结果

那自然看上去不怎么好对吧

那中间这幅图

然后这个做了一个什么操作呢

他做了这么一个事儿

就是说啊对于这个呃这个呃你每一个平面哈

然后它本身不是有四个顶点吗

我每一个顶点我都算出一个它顶点对应的法线哦

那每个顶点有自己的法线

那我就每个顶点做一次着色

然后做一次着色之后

然后那那自然是这样

比如说这三个顶点围成一个三角形

那在三角形内部

那那这些它他们三角形内部的这些点应该都是什么颜色呢

那没关系

我可以通过一种方法叫差值的方法算出来

所谓差值就是说啊我知道三个三个三个顶点呃

它们的颜色是什么

我问三角形内部某一个点

它的这个颜色是什么

并且我希望它有一个平滑的过渡啊

这个叫差值之后给大家详细说

那呃回到这个问题上来

那么这里着色应用在什么上面呢

应用在每个顶点上进行一次着色

那右边这个我相信大家可以想象得出来对吧

右边的这个着色应用在哪儿呢

它应用在每一个像素上

也就是说我对于这个呃每一个这个四边形或者三角形啊

顶点求出一个法线的

然后把这些法线的方向在三角形内部进行插值

然后就得到了任何一个这个像素

它都有一个自己的法线方向

并且我可以做一遍这个着色

那就是说我这个着色应用在每一个像素上

那我可以得到一个非常好的结果而来

那就是这样的对吧

那这就是它的这个本质的区别

那咱们把这些呃这些方法都做一个正规的定义好

### 00:23:18,10

![00-23-18](tmp/00-23-18.jpg)

第一如果我说每一个三角形它是这个平面啊

然后呢我把这个这个三角形的这个法线求出来对吧

这个好求

然后怎么怎么做呢

这个三角形的两两边做一个差距

就就就可以求出这个呃三角形的这个法线

好求出一个法线

然后呢我这个我这个根据我这个我这个呃 lighting 啊

view 啊这个方向

然后算出一个这个设定的结果

那就是这个三角形长什么样

那自然对于三角形内部

它不可能有这个着色的变化

也就是说得到一个完全一样的这个结果好吧

哎那也就是说可以得到呃右边这么一个结果啊

那当然结果不太好

然后但是呢他有他自己的名字叫做 flat shady 啊

然后我们叫叫这个名字

然后呢我们说的第二种方式

### 00:24:01,70

![00-24-01](tmp/00-24-01.jpg)

哎这里有同学要问了

就怎么求啊

我不知道啊

给我一个这个 3d 的模型

我一个我这个比如说一个三角形

它的发现我会求

可是一个顶点的法线

我怎么求啊

马上就给大家说

现在咱们先假设这个顶点的法线能求哦

那那那求出来之后每个顶点做一次着色

那每个顶点就有颜色了

那每个顶点比如三个顶点固定一个三角形

那三角形内部的颜色通过差值的方法算出来

大家可以看到结果比这个 flat shading 要好啊

然后这个这个但是基本上来说

比如说像右边这个球

当这个三角形稍微大一点的是吧

这个高光什么我可能就看不见了

然后就会存在这种情况

当然这个对于这个球来说啊

这个嗯这样着色效果也并不是特别好对吧

然后这样的着色在每一个顶点上进行一次着色

也是有名字的

叫 gotiating

然后这个显然它这个不是个英文的发音啊

听起来发音有点像骨肉啊

就是这个意思啊

所以对比一下啊

flat shading 是一个三角形

grow shading 是一个呃呃顶点

那自然对于每一个像素

### 00:25:06,80

![00-25-06](tmp/00-25-06.jpg)

如果说啊我我把这个三角形的三个顶点求出来

各自的排线在三角形内部

每一个像素上我都可以插值出一个这个呃独特的法定方向

那么我对每一个像素进行一次这个着色

那么就可以得到一个相对比较好的结果

这个结果就叫做 phone shing

然后这里呢呃区分一下概念

我们之前提到一个这个呃这个着色模型

某一种着色模型叫呃不灵魂摆设模型啊

这个这是一种着色模型

然后只不过它中间出现了缝这个名字

然后呢这个这里的 funciation 指的是一种着色频率

这是碰巧这两个事情是由同一个人来发明的啊

另外多说一句

这个冯这个人呐真是天才嗯

大家可以看到这个他这个至少在目前这个课上的

他就已经留下了两个事情的

第一是这个着色模型

第二是这个呃逢时 ating 就是逐像素做这个着色对吧

然后但是很可惜是天妒英才啊

他这个读完博士之后呃

好像是这样

在博士期间好像就是这个和病魔作斗争

然后读完博士之后

第 2 年好像就去世了

呃这个确实是一个非常惨痛的事情啊

然后这个嗯诶这个这个渲染界好像一直是挺惨的

然后去年还有一位这个欧洲的渲染的大牛

然后去世了

这个呃也是英年早逝啊

然后当然了

这个都给大家说一说吧

这个这个之后的这个这个呃唉所以更应该把这个东西写好啊

就是这个意思行吧

那咱们提到的这三种不同的着色模型啊

flat shedding 是逐三角形

grow shading

逐顶点风切 ding 是读这个呃

主主主像素好

然后就这三种

然后呢这三种其实大家要硬说它有什么样的区别呢

### 00:26:46,46

![00-26-46](tmp/00-26-46.jpg)

这个其实这也取决于具体的模型啊

然后就是说我们不能始终说这个

比如说这个呃 flash shing

它就一定会很差

为什么呢

大家看这么一个这个 3x3 的这么一幅图

这个图什么意思呢

就是每一行啊用的模型都是一样的

而行与行之间

比如说第一行跟第二行相比

第二行就用了更多的三角形

就这个几何形体本身更加的密集了

就是几何形体本身定义的更加光滑

那就是说呃第二行跟第三行相比

这每一个这块几乎都几乎都小的看不见了

那在这种情况下

就是说呃大家可以看到哦

当我的这个几何足够的复杂的情况下

哎我其实就可以用一些相对简单的这个着色模型

然后得到的结果其实还是挺好的对

然后就是就是说它有这么一种关系在里面

也就是说着色频率对吧

它取决于这个这个面或者点

或者说这个呃顶点

或者说像素

它它们本身出现的频率

当我的这些面出现的频率已经很高的情况下

我就不再需要去用这么复杂的这个这个呃逐像素的这个呃着色

当然话反过来说就是这么一个意思

就是说啊这个我们如果看第一行

那我们知道啊

phone shading 自然会有更好的结果

但是由于每个像素都要做一次着色

那肯定要比这个 flat shading 这个开销要大

但其实呢如果这个呃模型变得足够复杂

尤其是今天这样这样一个这个复杂的模型这么一个情况啊

这个这个嗯当这个模型足够复杂的时候

可并不一定说我这个竹这个面或者是猪这个顶点得到的效果

就比如像素要差

然后呢这个呃逐像素做也不见得

就是说这个呃工作量要比这个竹这个表面呃要办

因为如果这些这个三角形面数量已经多得超过了像素数

那可不是说做 flat shading

反而这个计算量要大的嘛

对不对

所以说这个就是取决于啊具体的这个这个呃物体

当然对于这个常见的一些这些呃这个面本身不是特别特别密集的

那当然我们还是说 for shing 会给大家一个非常好的结果好吧

这这里大概就是说这个关于这个呃着色频率的一个探讨好吧

### 00:29:03,96

![00-29-03](tmp/00-29-03.jpg)

那么我们留下了两个问题

对不对

留下了两个问题

什么问题呢

第一我怎么知道逐像素的法线是什么对吧

哎不逐顶点的法线是什么

我只知道说一个三角形的法线怎么算

哎很简单

就是说呢呃有一个理想化的情况是

首先如果你知道你这个模型我是用一堆这个比如说三角形表示

但其实我是想表示什么对吧

比如说对于这个模型

假如说我想表示的就是一个球

然后我拿一个三角形来表示

那没关系

那我知道任何一个顶点其实对应的是这个球上面的一些点

那那我自然可以通过呃他所在的这个球的这个位置算出来它的法线

那对于这些不同的顶点

那它原本表示的是球对吧

那它的法线应该自然是从球星联想这个点这个方向诶

那这是好啊

可是你这个平常不可能有这么好的事情对吧

怎么可能知道说它这个背后视图表示的是什么呢

那么人们发明了一种办法

### 00:29:53,80

![00-29-53](tmp/00-29-53.jpg)

很简单

怎么做呢

就是说任何一个顶点

这个肯定它都会和很多个不同的三角形有所关联对吧

就是说这很多三角形在这个例子上

大家可以看到这里有四个三角形

它们都共用这么一个顶点

那么很简单啊

那我这个顶点的法线我就认为是它这个相邻的这些面的法线

求个平均就可以了

那这个就是大家发现了一个一个这个很不错的一个方法

而直到现在还是这个为大家所用

当然了

这里呢一个简单的平均也许说明不了什么问题

就比如说这里有一个三角形超级小

有一个三角形超级大诶

那我们就想是不是这个超级大的三角形应该会贡献的更多

也就是说我要把这个四个法线求平均啊

可能做一个加权的平均

这个权可能就是三角形的面积

会不会得到更好的结果呢

然后答案是是的

就是这么回事

就是说目前来说大家的算法

就是说这是一个诶很简单的一个一个一个算法

就是说这个呃就是把这个顶点所关联的呃面呃

三角形面也好

多边形面也好

它们的法线求一个平均

不管是这个简单平面还是加权平均

那这就是我们如何去定义这个主顶点的法线好

那咱们这是一个

### 00:31:04,66

![00-31-04](tmp/00-31-04.jpg)

然后另外一个呢就是说啊这个如何去真正的定义一个逐像素的发现

也就是说在三角形的内部

假如说我已经知道它的顶点的法线是什么了

那如何得到这个内部一个平滑过渡的一个法线呢

大家可以看这么一个例子对吧

这里这个左边这个法线我知道右边这个点它的法线也知道

那么它中间的法线应该是往这些方向去的

但是有一点哈

这里要跟大家说清楚

记得法线所有的法线都是方向

所以应该求出来了之后

应该要给他求一个这个这个规划

把它变成这个呃单位向量啊

然后就是说保证它们长度和呃就都是相同的

这些对

那么呃回到这个问题上来

嗯

给这个顶点的这个法线怎么样

查支书这个中间的一个这个呃发现呢

那这个就需要用到这个呃所谓的重心坐标

重心坐标马上就要给大家说好吧

然后这里啊到此为止

这个着色频率基本上就已经说明白了好吧

然后啊咱们在讲这个呃渲染管线之前呢

### 00:32:00,10

![00-32-00](tmp/00-32-00.jpg)

我我正好也停一停

然后看一看大家这个啊回答的问呃

问的问题哈

看一下啊

哎呀呵呵呵呵

诶什么鬼

这个好吧嗯

ok 好好像暂时没有特别那个的问题哈

就是说有同学问这个这个这个这个这个呃怎么得到点所相连的三角形

哦

这个是属于这个模型在定义的情况下是怎么定义的啊

然后这个这个嗯暂时咱们先不说到了几何这里

我们再说好吗啊

ok 好啊

那咱们现在进入这个下一块吧哈那我们现在已经这个回忆一下啊

着色模型说了

然后着色模型怎么用说了

那么现在就是说我们把这些所有的东西都合在一块儿

那就已经可以说给我三维的模型

给我这个不同的光照条件

我就已经可以得出这个这个呃渲染的结果

那把所有东西都合在一块

得到的东西就叫做图形管线

叫 graphics pipeline

当然了

这个说法是以前古老的说法

我更愿意管它叫做这个实时渲染管线

因为图形学的东西涉及的东西太多

就是说我们说了啊

关于实时渲染方面

就嗯在我们的课程里呃

都只能算上是 1/4 的内容

当然讲的这个课时数稍微多一些啊

然后就是说嗯这个嗯对于其他的一些这个渲染方法

他当然不是这么做的哈

我们这里说清楚啊

好那嗯就是说我们要提到的就是图形管线或者实时渲染管线

什么意思啊

大家可以看一下

### 00:33:37,90

![00-33-37](tmp/00-33-37.jpg)

就是说啊就是说我如何从这个场景到最后一张图

中间到底经历了一个什么样的过程

这个过程就叫做 pipeline

就叫做管线

所以它其实表示的是一系列不同的操作

然后这些东西呢其实已经跟大家说明白了

然后这个比如说咱们可以看一看它到底经过了什么过程啊

就是说呃大家看到呃从一开始输入呢是一堆这个空间中的点

然后呢并且这个呃经过了这个这个这个第一步之后啊

我们要做一个投影对吧

我们之前讲了各种各样的这个变化啊

投影啊

我们最终首先是要把这个三维空间上的点

然后投影到这个平面上对吧

投影到屏幕上

然后呢这些点它们会形成三角形

然后形成三角形

我们知道形成三角形

这个这个我们还要把它画在屏幕上呢

屏幕可是离散的

那怎么办呢

那咱们就通过这个光栅化把它给离散

成为不同的这个所谓 fragment

这里借用的是这个 open gl 里面的一个概念啊

然后就是说呃其实 fragment 就是类似类比于像素吧

就是在这个不做这个嗯

这个呃 mi sample

anta lion

就 m s a a 这种呃

我们就可以认为一个 fragment 就是一个像素

那咱们就说它是一个像素好吧

那么这个呃当我把这个不为三角形在屏幕上都打散成不同的像素之后

然后我就可以对它这个呃进行着色

然后每一个这个像素我都知道它应该长什么样

这应该是什么样的

最后一个颜色

最后我就知道整个一个屏幕上应该是一个什么样的颜色了

那如果说我的这个呃这个用了这个

比如说 m s a a

那就是指好多个不同的 fragment

会形成一个像素的颜色

那如果大家已经做了这次作业对吧

大家都知道对吧

然后我维护每一个这个 fragment

它对应或者说 sample 啊

对应的它的这个这个深度

然后颜色

然后我最后再把它拼成一个图

我就不会拼出三角形的黑边啊

就是这么个问题好

那么这一个呃整个一个过程呢

这就是我们处理这个呃

这个嗯从三维场景到最后渲染出二维的一幅图的一个基本操作

而这个操作是已经在硬件里面写好了的

现在的是整个一个这个显卡

他所做的操作就是基本上是这么一个操作

整个在 gpu 里进行

然后呢这里有一点啊还没有给大家说啊

这里呢就是就是这个大家可以看到说我们一开始啊

就在说这个三维空间中这个不同的三角形

然后把它投影到这个屏幕上去

那这里我是这个为什么说我把三维空间中的点投影到屏幕上去

然后再把它连成三角形呢

是这么一个意思啊

其实它没有什么特殊的意义

就是说我们如何定义空间中的一个模型啊

咱们可以想象一下

我们可以定义它所有的三角形顶点

然后再定义每三个顶点会形成一个三角形对吧

我们把这两部定义给分开

其实一样的

跟我定义所有的三角形是一样的

我先定义所有的顶点

在定义哪三个顶点会形成一个三角形

定义一系列的这些东西

那然后就是说我只用把三维空间中的这些呃点投影到屏幕上去

变成二维的

变成二维的

然后呢它它们之间的连接关系自然不会变

还是仍然是原来的这三个点呃

现在投影了之后的三个点形成一个三角形

那所以说呢我只需要对顶点进行操作就可以了

所以说大家可以看到啊

这里面这个呃我们所说的这这三个大的步骤

第一是这个顶点的处理

也就是说这个嗯投影变换啊这一块的东西

然后第二个步骤就是这里啊这个光栅化涉及到怎么样去采样

然后怎么样去做深度测试

然后把这个呃实际上在屏幕中能显示出来的像素给找到

然后第三块就是我们说的着色

那把这三块都合在一块儿之后呢

自然最后就可以得到准确的结果

没问题

那咱们看几个例子哈

### 00:37:20,90

![00-37-20](tmp/00-37-20.jpg)

这个我们之前说这个做 model view projection mvp 变换

那个变换在哪呢

那就是每一个顶点我做一个变换对吧

没有问题

### 00:37:29,93

![00-37-29](tmp/00-37-29.jpg)

那这个我这个涉及到这个对这个屏幕上面这个每一个像素中间采样

然后看是不是在三角形内

这一步是在干什么呢

这不就是在这个光栅化对吧

然后呢这个这个当我光栅化产生了一系列的这些 fragment

### 00:37:39,43

![00-37-39](tmp/00-37-39.jpg)

或者像素的时候

我要判定啊它是不是这个呃

可见那就是说呃是在这一步发生

当然严格意义上来说也可以把它归为光栅化的一部分吧

就是这里分的比较细啊

就是说 z buffer 就是我们所说的深度缓存

就在做这个事情

然后呢我们说 shading 谁定呢

### 00:37:58,43

![00-37-58](tmp/00-37-58.jpg)

这里大家会会看到这么一个事情诶

这里是 ding 是发生在这个顶点和这个像素

这个这个这个都会发生

这是为什么呢

呃这里呢其实就是说呃考虑到不同的这个着色频率

如果说我们考虑这个着色是这个 groo shading

也就是每一个顶点我进行一次着色诶

那我自然就是发生在这个着色

就可以发生在这个顶点的处理上

顶点可以做这个呃投影也可以做着色

没有任何问题

然后呢如果说我做的风水岭

那自然是得等这个像素都产生了

所以我们在 fragment 里面做

所以大家可以看到啊

就是说这这里重要的是什么呢

如果想做着色

重要的就是这个顶点如何着色

或者是像素如何着色

然后在现代现代的 gpu 里面

然后就是就是这一套渲染管线

它是允许有些部分是可编程的

所谓可编程的就是你说了算

就是你说这个顶点如何去被着色

然后这个像素如何去被着色

然后就是说你可以定义这个事情

然后定义了之后呢

自然就是说你写一段代码

然后让它能够生成各种各样的这个不同的这个着色的结果

那么这里说的容易就是说整个这个这个实时渲软件啊

几乎就是在做这么一个事情

就是所谓写这个这个这这部分要如何运行

那什么样的代码来决定这些顶点和这个像素要如何这个呃运作对吧

这个处理如何运作呢

这部分代码我们就管它叫 shader

这部分 shader 呢

就是说这个是控制说这个顶点和这个呃像素是如何进行着色的

那就是这么个意思行

那咱们这个多说一句

### 00:39:36,23

![00-39-36](tmp/00-39-36.jpg)

马上就会给大家说这个硬件上的事情好吧

然后嗯这里呢我们有一块呃还没有说

这就是下一个话题

我们很快就要给大家说呃这么一个事儿啊

什么事情呢

大家看右边这个三角形哈

这个三角形这个显然是说这个我没做任何的什么差值什么东西对吧

我这个这个呃我其实三角形内部它每一个点

它的应应该是对应的一个这个这个木头纹理的上面的某一个点

对不对

是这么个意思

就是说在三角形内部能够看到一些这样的变化

这是怎么回事对吧

就是说我如何定义这个每一个这个像素

或者说三角形内部不同的点

它都拥有了一个完全不同的属性

怎么样才能这个让三角形显示出这么一个这个呃

上面有一张图的三角形诶

这个就叫做纹理映射

好

咱们马上就要说好

### 00:40:25,13

![00-40-25](tmp/00-40-25.jpg)

在这之前我们把这个 shader 把这个概念完善一下

刚才我们已经说了

现代的 gpu 允许大家自己去编程

来解决这个顶点和这个呃和这个呃像素如何去这个呃操作

就是如何做他们的着色

那么正常情况下呢

这个时候需要大家去写这个 shader

如果大家要实现一些复杂的东西

那么这个 shader 呢它本质上是一些这个呃能在硬件上执行的语言

咱们这里举一个例子

这个 open gl 这一块呢对吧

open gl 是一个这个呃图形学的 api

然后呢你可以用它来写一些这个 shader

那么 shader 首先我们说一下是这个意思

shader 是每一个顶点或者是每一个这个呃 fragment

或者说像素它的这个呃它会执行一次

然后就是说你写的这个 shader 其实是一个通用的

你不用指定说每一个这个 fragment

我每一个像素我怎么样去执行

我写一个通用的程序

那么每一个像素都会这么执行

是这个意思好吧

然后这里先确定就是不需要大家写 for 循环

在这个 shader 里面

你就只需要管一个顶点或者一个像素怎么样运作就可以了

好那是第一个事情

第二个事情是这么回事

就是说如果我写的是顶点的操作

然后这个 shader 就叫做 vertex shader

叫顶点着色器

然后如果说我写的是像素的操作

那这个 shader 这个叫做 fragment 或者 pixel color

然后 a pipixel shader 叫做像素着色器

或者说这个 fragment 啊

这个其实大家翻译叫片段或者片段着色器或者像素着色器

其实一回事啊

然后就是说呃那就是说这是他们的名字

然后呢咱们现在看一个具体的例子

那么对于这个呃像素着色器

然后他要干什么呢

他要告诉说这个像素最后的颜色是什么

那也就是说对于一个像素来说

我要写清楚怎么样算它最后的颜色

并且把它输出出去

那么这里做的事情就是这么一个一个着色的过程

那么呃这里是一个简单的一个这个呃 open gl 的一个着色语言

让简称 gl sl

它的一个这个呃像素着色器的一个小程序

这个着色器说的是什么意思呢

说的是啊

我这个呃有两个全局变量

全局变量啊

跟 c 加加里面一个道理

这个 uniform 指的就是全局变量

而这个全局变量是一个纹理

纹理是什么意思嘛

你再说啊

全局变量里面有一个这个光照方向

也就是我认为每一个这个像素它都有一个固定的这个光照方向啊

它不会变

然后呢

那么对于不同的像素

在不同在这个三角形内

它可能有一些差值的值对吧

比如说这个我们刚才说这个呃顶点的法线

咱们这里忽略这个 uv 啊

然后我们这个看顶点的法线

这个顶点的法线是插值出来的

也就是说对于这个呃这个顶点它可能有三个顶点

有不同的这个呃发现

那么我不用管它

到了这个这个像素里面

我自然而然这个这个整个一套 open gl 就替我做好了

我就知道他是这个差值出来

每一个像素它的法线是什么

叫 nm 这里

然后那么这里呢我们可以看它这个做了件什么事儿

我说了啊

就是说我们指定的是每个像素都这么执行

所以不需要一个 for 循环

那每一个像素我可以拿到它一个这个 kd 就是它的漫反射系数怎么做的

这跟文理相关

咱们忽略它

那就是说呢我这个这个呃慢慢的系数

如果乘以说这个假如说光照是一个常数啊

这是一个超级简化的版本

我只要乘以它的那个呃 l 和 n 的夹角对吧

呃夹角余弦怎么做到这个 l 的方向

然后和这个法线方向求一个点称它

这里显然是认为这个方向这个入射方向是向内的哈

在跟我们的规矩是不一样的

我们规矩是这个入射方向本来就是朝外

所以没有这个负号

然后做一个 max 的零呃

零这么一个处理

当然它结果肯定小于一

没有问题

就是说这里其实就是最最简单的逢魔型的漫反射的部分

写完了之后

把它给返回到一个这个值

这个值是一个固定的值

叫做 gl flag color

就表示说我这个像素或者片段它的颜色是什么

所以说从这个代码上来看啊

这个核磁加加非常非常非常非常相似对吧

它有全局变量

它有这个差值数的变量

然后中间怎么样计算

还有各种各样提供的方便用函数

比如这个点乘对吧

点成两向量

点乘 dt 什么什么

然后这个如果要把它这个值限制在 0~1 啊

用一个 clamp 01

然后中间的值这个就保证了它这个值一定就在零和一里面

然后最后返回这些值

然后呢我们写这个 egg 对吧

我们在 c 加里面用 egg 这个库

我们写这个向量怎么写啊

bor 3 f 对吧

表示一个 float 型的这个三个数的向量

那这里很简单

vex 3 就解决

然后 vex 4 呃

可以这个比如说前面呃给他输入一个 vex 3

后面再跟一个数

那自然就变成 vex 长度是四个 vector 向量对吧

那所以说这个嗯 g l s l 呢其实很好写的

然后对于这个 shader 来说

你就可以指定好每一个这个像素如何去着色啊

这就是说这个这个整个一个这个啊所谓着色器也就是 shader 啊

### 00:45:24,13

![00-45-24](tmp/00-45-24.jpg)

他到底在干什么

那咱们把这个事说清楚就可以了

他就是要能够能够定义呃任意的顶点怎么样操作

任意的这个呃像呃呃这个这个像素或者片段如何去操作

那就是这一点理解到了就没问题

那咱们现在回到第一节课我给大家说的这个事情啊

就是说呃咱们讲到这个为止

其实就把这个整个呃图形管线的部分全部都涵盖到了

如果在这个大家把这个作业做下来

就会发现啊

这个整个一套这个光栅化

整个一套这个成像这个实时渲染

它的基本思路

我就已经都给这个涵盖到了

那也就是说如果在这个基础上

这一系列图形的 api

他们是如何运作的

然后他就会会发现非常简单

我只需要指定这个场景中的东西

他们怎么样去这个运动

怎么样旋转

怎么样摆放

然后相机怎么样摆放

所谓的这些这些这个呃举证啊

都不用自己来做的

他这个都有这个很好的一些这个 api 帮你生成他们的举证

然后如果你想写着色的话

很简单

你就在这个这个顶点

或者说在这个呃像素里面

然后实现这样的着色器

然后他们的语法也都很容易

然后可以可以这个很方便地写出来

那么呃到此为止

大家就可以通过所学的知识去这个真正的写一些

实时渲染的这个代码了

然后这里呢我给大家推荐一下这个呃一个网站叫做 shader toy

### 00:46:49,93

![00-46-49](tmp/00-46-49.jpg)

然后这个这个网站是干什么的呢

这个网站就是说你可以自己这个免去你写这些什么 open gl 啊

什么 direct x 啊

这一系列背后的东西

你只用关注这个场景怎么样去渲染

你就是说你只用写所谓的着色器

所谓这个这个呃顶点和这个呃像素他们如何着色就可以了

那也就是说它是一个这个这个在这个网络上直接可以执行的

一个一个呃在这个网页上直接可以执行的这个程序

然后你把它这个写出来之后

你就可以看到这个结果是什么

那么 shader 呢我刚才说这个我每次提到这个事情啊

我觉得这个 shader 真是千变万化

大家这个可以可以这个这个做的非常非常惊人

比如说给大家看这个蜗牛的这么一个例子是什么呢

### 00:47:37,90

![00-47-37](tmp/00-47-37.jpg)

这个呃我们放起来啊

ok 这个蜗牛呢它是由各种各样不同的几何形体来定义的

我们管它叫这个隐式的几何形体

### 00:47:50,20

![00-47-50](tmp/00-47-50.jpg)

然后这个之后讲几何会说他并没有用任何的三角形啊

然后就是说它的所有的几何形体都是通过数学方法定义的

### 00:47:57,83

![00-47-57](tmp/00-47-57.jpg)

并且呢呃大家还可以通过 shader 来不断的来调整这个几何形体

它就应该长什么样

就是说如何去这个得到这些几何形体的投影

### 00:48:07,33

![00-48-07](tmp/00-48-07.jpg)

这里和我们三角形的投影不一样啊

这一然后呢当然可以做 cad

大家可以看到这个呃

这个壳壳的材质看上去就很像这个这个这些固体对吧

### 00:48:18,23

![00-48-18](tmp/00-48-18.jpg)

然后蜗牛本身看起来就像是透明的

这个半透明的这么一种感觉对吧

然后就是说这是非常非常非常厉害的

就是说通过 shader 可以实现超级多超级多的这个好东西

然后这个呃链接什么的都有

然后呢大家之后就是说学完这门课啊

或者说到此为止啊

没有什么压力

然后呢然后自己没事去写一写这个 shader toy

这上面的这些 shader

这是非常非常有趣的事情好吧

然后呢这个呃这个例子当然了是超级高端的一个例子

然后大家都会觉得这个叹为观止

这个确实是厉害

当然了

这这里就是说这个动画整个的这个形成过程啊

真正如果大家访问这个网站

它会发现这个过年还会动啊

它这个 shader 里面还做了动画

这是确实是大神啊

这个大家好好练就没有问题

好

那么这个呃这就是这个例子

那咱们现在说一说啊

这个这个现代图形学的发展很简单

### 00:49:14,76

![00-49-14](tmp/00-49-14.jpg)

就是说随着这个 gpu 这个所谓这个 graphics processing unit 对吧

然后这个这个 gpu 的发展

然后我们现在的显卡可以同时在很短的时间内处理大量的几何

然后把它给放在屏幕上

并且它的着色非常非常的快

高度并行

然后就是说你这个在你这个着色这个像素的时候

有很多其他的像素都在同步的进行着色

那大可以可想而知有多么快

对不对

然后就是说这个现在的这个这个图形学发展就是往这么一个目标上去

我有一个超级复杂的场景

像这个场景

这个场景呢就是实时渲染的一个场景

是这个 unreal

大家听说过吗

叫叫虚幻引擎啊

这个虚幻引擎非常厉害

然后他们这个就相当于这个引擎啊

比如说我想做一个游戏

但我不需要了解特别多图形学的知识

不需要理解特别多这个人工智能知识

这各方面都已经写好了一些

这个你直接可以拿来用的这些方面

那当然了

作为游戏引擎

它肯定要把这些方面给做好

特别是图形

那所以说就是他们做了这么一个事情

就是说他他们可以允许这个呃

这个有一些这个经典的算法就已经实现好了

怎么样去做阴影

怎么样去这个呃对吧

怎么样做这个近似的实施是呃这个这个呃叫什么来着

全局光照也就这些事情

然后把它给放到这个呃一个实时的这个这个画面里面来

然后大家就可以关注游戏的开发

而不用特别关注这个图形图形呃

背后是怎么实现的啊

那这是好事情

但是对于我们来说

我们希望了解这个事情对吧

然后就是说现在的图形

这些引擎都是可以支持这个呃非常多非常复杂的这个场景

然后也可以做得非常快

然后呃所以当然是一个很好的

对不对

然后这个我也很期待

看到说之后这个这个游戏引擎应该往什么样的方向发展

能不能做得更好更逼真

对吧好

那这是一个事儿

然后另外一个呢我们刚才提到 g p u 对吧

### 00:51:05,33

![00-51-05](tmp/00-51-05.jpg)

然后 g p u 自然就是说这个整个一套这个图形管线的这个呃

硬件实现对吧

我们这么理解它就是说嗯它在硬件的层面上就实现了

说比如说三角形怎么样去做这个呃

各种各样不同的这个这个这个这个光栅化

然后怎么样去实现投影各种各样的东西对

然后呢有一部分是可编程的

就是我们所说的着色器对吧

我们提到了两个顶点着色器和这个呃片段或像素着色器

但其实随着这个 gpu 的发展

随着说这个这个呃现在技术越来越进步

有越来越多不同类型的着色器产生

比如说这里给大家举个例子

有一个着色器叫做 geometry shader

它算算是几何的着色器

它可以干什么

说是叫着色器啊

其实相当于是呃某一种操作

你可以定义几何的操作

可以动态产生更多的三角形啊

这有什么好处之后我们会说啊

然后还有一种 shader 叫做 compute shader

computer shader 就更厉害了

这个这个就是说它可以做任何形式的计算

你不用把它给这个呃理解到他只能做这个图形学内部的一些计算

用 compute shader 它就可以完成各式各样的

我们管它叫通用的 gpu 计算

所谓 general purpose

gpu 叫 gp gpu

就是这么个意思好

然后就是说现在这个 shader 呢是非常非常厉害的

然后大家学这个这个呃新的一些东西呃

这个比如说 direct x 12 呃

大会学到很多很多各种各样新的技术

然后这些呢就是说在我们这个传统的这个基础上又有所这个加强

所以说这个是非常值得期待的一个发展啊

那么 gpu 提到这里啊

啊说起来说两句啊

第一这个 gpu 呃分两种

一个叫做集成的显卡

这些大家打游戏都知道哈

这简单给大家提一下

第二呢就是说 gpu 本身

### 00:52:57,76

![00-52-57](tmp/00-52-57.jpg)

它这个大家就可以理解成是一个高度并行化的处理器

咱们经常说 cpu 对吧

哪个什么 i7 i9

48 核不得了了对吧嗯

然后 a amd 推出了 64 核

然后就是说啊这些这个所谓核心的数量

咱们就可以理解成所谓可以并行的线程的数量

那么这个大家如果学过这个高性能计算的话

还是知道 gpu 的这个这个呃并行度

也就是说同时进行并行的这个数字是相当相当惊人的

这个数字要远远超过这个 cpu 的几十

虽然每一个它的这个性能并不是特别的强

但是胜在它这个这个并行度很高

所以特别适合做这个途径学的这个这个这个项目

就是说我很多这个这个呃像素它的着色方法都是一样的

对不对

然后就是说我们通过这种方法

然后然后就是说我定义一个

然后很多的这些呃像素他们执行的代码基本相同

这就非常非常利于做这个并行计算

那这就是 gpu 的另外一个这个特点

那这给大家说明白好吧

然后呃那这里就是这啊

那咱们把这个 gpu 说好

ok 那么咱们图形管线到这告一段落

### 00:54:04,26

![00-54-04](tmp/00-54-04.jpg)

那么下一步就要说呃纹理映射的事情了

那么在这儿我先暂停一下啊

看一看大家有没有什么其他的问题哦

这个好诶

ok

好吧

好像这个这块倒是挺容易明白的对吧

这个基本上来说就是对咱们之前所讲过的这些内容的一个总结

这个这个整个一套图形渲染是一套什么样的一个一个思路

然后每一块都是如何解决

那么咱们现在回过来解决这么一个遗留问题对吧

我希望得到一个三角形

三角形内部是填充了某一张图的一个一个一个这个这个现象

诶

这个是是是什么意思

我们怎么做对吧

然后这里就要提到纹理映射这么一个概念

### 00:54:56,43

![00-54-56](tmp/00-54-56.jpg)

那所谓纹理映射其实我们在做一个什么事情啊

这里这个通过这张图

咱们希望把这个事情给说清楚

那大家可以看到这幅图其实非常简单

两个台灯在照亮一个地板和一个球对吧

然后如果咱们只盯着这个球来看的话

那其实他的这个着色我们会写对吧

如果我们认为台灯的灯灯光这个光源啊是一个点光源

那这样的话

那无非就是两个点光源

它的贡献都加起来了

如果我们用这个呃这个布林缝这个着色模型

那么大家可以看到

如果我们只盯着这个漫反射来看啊

那漫反射系数

然后乘以它这个光要考虑一个这个嗯这个光源

然后他的衰减

然后他的接受啊

那没问题

这个是是可以这么做的

然后但是呢这个球上面诶我可以看到它有不同的这个不同位置

有不同的颜色

大家可以看到诶这里有个五角星

然后这里是黄颜色

这里是蓝颜色

诶他们的基本区别是什么呢

他们基本区别是哦

他们其实共用同一个着色模型

只是说他们本身的漫反射系数发生了一些改变

也就是说我们希望有一种方法能够定义对于一个物体

它上面的任何一个点

它们的属性

那呃怎么理解呢

对于这个咱们看另外一个例子

对于这个地板来说也是如此对吧

地板来说

假如说它是漫反射的

那有灯光照亮它

然后它在任何一个地方啊

它其实有自己的漫反射系数

然后它这个慢慢技术反应在它这个呃木头的这个这个纹路对吧

它也可以看得出来对吧

也就是说啊我们希望定义这个在物体不同位置定义一个不同的属性

那这里其实就是说我们呃引入这个纹理映射的一个最基本的思路

倒不是说我们完全需要用它来定义这个漫法式系数啊

它可以定义任何任何各种各样不同的东西

就是说它的根本作用是定义任何一个点的不同属性

那咱们现在继续进展

那么怎么定义一个这个任何一个点它的基本属性对吧

### 00:56:42,33

![00-56-42](tmp/00-56-42.jpg)

那咱们需要先理解说我们定义在哪

首先第一我们把这个属性定义在物体表面上

当然了

我们要考虑这个任何物体表面任何一个点应该是什么样的颜色

我们要做着色对吧

那物体表面怎么样去理解

那这里呢首先我做一个这个呃

怎么说呢

声明对吧

任何一个三维物体

它的表面其实都是二维的

哎这个事情怎么理解呢

这个其实其实很好理解

大家看这个这个地球仪对吧

任何一个地球仪呢显然是个三维物体

三维的球

它的表面

但是呢我们可以把这个必修一的这个这个这个它它上面这个呃

他的这个这个这个图啊

呃给撕下来

比如说中间给割一道口子

然后把这个整个一张图给拿出来

拿出来之后呢

然后往平面上一放

诶那可不是变成一个平面了

对那这也就是说一个事情啊

就是说哦这个三维物体的表面

其实呃虽说整个物体是三维的不错

可是对于表面来说

它们其实是二维的

那有同学要抬杠

说明我多个物体

那多个物体

那我可以把它的表面展开成多个平面

再把它放在一块呢

还是一个平面

对不对

就是这个意思

所以说这个这个嗯就是说啊物体的表面其实通过这种方式呢

我可以和一张图有一个一一对应关系

那么这里我们就定义一个所谓纹理

纹理是什么

纹理就是一张图

这张图我可以任意的把它给比如撕开

用其中一块

或者说把它给这个这个拉伸啊

压缩呀

或者怎么样

就是认为认为它是一个这个有弹性的这么一张图

我就把它蒙在任何一个三维物体的表面

这个过程就叫做这个这个纹理映射

那映射啊自然是一个一一对应的关系

那我们就找到了一个这个物体表面

任何一个点和和这个纹理上面任何一个点

它们之间的关系

对不对

那就是这么一个思路

那咱们看一个具体的例子啊

### 00:58:32,43

![00-58-32](tmp/00-58-32.jpg)

咱们看这个左上角这个独眼巨人啊

这个渲染出来的结果

这就是我们布林冯能够得到的一个结果

没问题

然后但是呢我想让它上面有一个图出现

那怎么办呢

根据我们刚才的思路

就是说啊

我们要把一张图给贴在这个这个表面上面去

那我们自然要知道怎么填对吧

那我们想啊三维空间中最基本的东西是什么呢

肯定是一个三角形

那么如果我知道一个三角形

它在这个物体上

比如说这里有一个三角形对吧

在物体上它应该如何映射到一个纹理上

也就是说它在纹理空间上是哪儿就行了

也就是说呃这个在物体上大家可以看

比如这个三角形哦

这个三角形啊

它在纹理上它对应的是呃在这里

也就是说啊我的任意一个三角形的一个顶点啊

它都都都能找到他在这个呃这个纹理上

它在哪个点上

大家就有同学会问了

那这个事情我怎么知道嘛

哎这个事情呢就是说这个嗯有两个解决办法

第一就是说呃需要艺术家的这个这个创造

就是说现在这个很多模型都是这么做的啊

他做出一个模型

然后大家把这个模型通过一种展开的方式

然后把它贴在这个呃放在这个纹理的不同位置吧

这个对应上这些是由这个艺术家们来完成的

或者说美工们完成的

就是说任何一个三角形它会被映射到哪儿

我们就认为已经知道了

可是对于美工来说是一开发是一个非常繁重的过程

第二呢是一个自动化的过程

这个自动化的过程怎么做呃

就是说啊给你任何一个模型

然后我有一个我可以把它给展开成一个平面

然后展开成一个平面

并且我还希望啊各个就是说这个产生的三角形尽可能的少扭曲

就比如说我原本三角形挺小

那我希望它这个展开到平面上啊

它还是挺小

然后这个这个这个三角形原本挺大的

还是应该挺大啊

那如果能保证这种性质

那就更好了

那么如果还能保证说比如说我这个整个一个物体啊

它是一个完整的一个物体

它是个处都是无缝衔接的

那我如果说把它映射到这个纹理上面

它还能保证说他这个纹理上面

它对应的颜色也是无缝衔接的啊

那就非常好的

那这个很难

这个是一个重大的研究的方向

叫做 parameterization 或者叫参数化

这块在几何上是一个非常非常这个厉害的研究

好吧

那咱们把这两个事儿说明白

就是说啊怎么把这个空间中一个三角形映射到一个纹理上

我们不管

我们就认为已经有了这么一个映射关系

我们知道这个纹理要如何贴到这个三角

在三不同三角形上

是因为我们在三角形上的任何一个顶点

我们都已经规定了它在纹理上的一个坐标

好吧

那么我们既然提到纹理上的一个坐标

### 01:01:06,60

![01-01-06](tmp/01-01-06.jpg)

那也就是说我在文理应该把它哦说起来哈

呃呃这样吧

这个稍微拖延一点点时间

这个应该很快啊

很快

那是这样哈

就是说呃我们刚才既然提到纹理上面的一个坐标

那我们就应该在纹理上定义一个坐标系

### 01:01:25,13

![01-01-25](tmp/01-01-25.jpg)

然后真正能指定说文理上面任何一个点的坐标

那么文理上是有坐标系的

比如说这里啊

大家看得清楚

文理呢是右边这么一幅图

这幅图其实相当于是给大家这个就是显示了一下啊

比如说这个红颜色这里就表示这个呃这个在 u 方向很大

然后这个绿颜色表示在 v 方向很大

那么整个这张图它就形成了一个颜色

然后不同颜色就表示不同的这个 uv 就是纹理上的坐标

那么我可以把这个任何一个这个这个物体

它的一个三角形如何映射到这个呃这个呃纹理上

然后可以把它显示出来啊

那就可以看到哦

左边是这么一个模型

右边是它的展开映射到这个纹理上的一个一个做法诶

所以是这么做的

那么定义一个 uv

然后呢这里多说一个 uv 的范围

通常大家认为对于一张纹理来说

不管你这个纹理是不是方块啊

就是说即使它是矩形的

长方形的也没关系

他都认为纹理的这个范围是 u 在 0~1 之内

也在 0~1 之内方便处理

那有同学问为什么这个也是一个约定俗成的一个事情啊

这算是相对简单的一个处理方法

不管它的分辨率是多少

不管它的这个长宽比是多少

我都认为 u 沿一个方向 0~1

另外一个方向 0~1 没问题好

那这里就是说这个呃嘿嘿呃 uv 好吧

然后纹理上有坐标的没问题

然后你看这个对于实际的纹理来说对吧

### 01:02:52,50

![01-02-52](tmp/01-02-52.jpg)

也是同样可以定义

那么我们就知道啊

三角形三个顶点啊

每一个顶点都对应一个 uv 对吧

这就是纹理映射呃

还是一样哈

怎么知道的

我们就认为已经知道啊

然后呢纹理就是说可以应用在不同各种各样不同的物体表面

### 01:03:06,20

![01-03-06](tmp/01-03-06.jpg)

而且啊这个大家可以看到

比如说对于这个例子来说

这是早期的一个渲染图啊

挺难看的

但是如果我们把它的这个任何一个点

它的纹理坐标可以显示出来

大家会看到是这样的

### 01:03:22,40

![01-03-22](tmp/01-03-22.jpg)

就是说大家可以看到哦

这个呃有一块纹理在在在这里啊

这 0~10 到一啊

假如是这样的

然后我不断地重复它

不断的重复它

就好像贴瓷砖业啊

我把这个这个给给贴上对吧

### 01:03:35,63

![01-03-35](tmp/01-03-35.jpg)

这这里对应一块这个地板

这个石头的这个这个地板或者是墙面诶

我把它贴上

然后不断地重复它

诶我就可以把整个一个物体给贴满

### 01:03:43,26

![01-03-43](tmp/01-03-43.jpg)

哎所以说啊这就告诉我们

谁也没说纹理映射

我说我纹理只能被用一次

我不同的位置我当然可以映射到相同的纹理的这个这个位置上

也就是说呃比如说大家看这个位置跟这个位置

它映射到了纹理

其实同一个地方没有任何问题

也就是对应了纹理

我重复多次就是了对吧

那么这里其实有同学可以看到另外一个事情哈

就是说诶我这个纹理我左右这么一重复

我很明显能看到诶这里有条缝

这上面有道缝

实际上对于我这个场景来说

### 01:04:16,90

![01-04-16](tmp/01-04-16.jpg)

回到这个场景上来说

我发现没有缝

这个就说明很很有意思

这说明什么呢

这说明我们这个纹理本身设计的好

### 01:04:25,0

![01-04-25](tmp/01-04-25.jpg)

使得这个纹理它往上往下各复制自己重复的时候啊

这个这个会无缝衔接

也就是说这个纹理的右边自然而然会接上这个纹理自己的左边哎

这上下也是这样

那这这就非常好了对吧

那那这个自然而然就有同学说

那我如何去设计这样的纹理

这是不是很难是很难对

然后这里呢就是说我们所设计的就是呃这个纹理

在这个呃图形学里面就叫做 table texture

tie

tie 是一块啊

tiable 就是 table

然后然后这种纹理这种纹理的设计是需要各种各样不同算法的

其中有一种算法叫 one tiling

然后就是就是这个王这个这个姓氏的名字

然后这个 one tile

然后现在是借这个

这是大家在使用的其中一种哈

就关于这个纹理的这种无缝衔接的合成

这是非常非常这个呃值得研究的一个事情啊

那这里就给大家这个这个简单说一下

是有这么回事儿

然后呃呃关于纹理呢

那咱们就说到这儿下一个问题

### 01:05:28,70

![01-05-28](tmp/01-05-28.jpg)

下一个问题很自然而然的事情

对不对

如果说我知道三角形三个顶点对应的纹理坐标 u 和 v 诶

那我如何知道三角形内部任何一个点

它对应的这个呃纹理坐标 uv 对吧

那也就是说这里又涉及涉及到这个差值问题了

那咱们今天这个讲的算是快的啊

这个前面文理已经提到了

那么咱们从下一节课开始给大家着重说这个差值

所谓差值什么意思

这个这个通用性的来说

就是说三个三个呃三角形的三个顶点有各自不同的属性

那么我如何在把这个属性在三角形内部做一个平滑的过渡给我

任何一个三角形内部的点

我都可以立刻知道啊

它应该是这个差值之后

它这个点上对应的属性是多少

那这就是我们要解决的问题

这里我们用的东西叫重心坐标

下节课再给大家说

那这节课就简单稍微拖点

他就是说说到这儿就够了

那么呃我这个时候再看一下啊

有同学问问题

你好

没问题

你看啊

哇哇哇这个嗯纹理和着色的区别和关系啊

纹理是用来定义这个这个嗯着色的时候

需要的这个这个嗯各个不同点的属性啊

就是这个意思就是说我不希望它着色的时候

每个顶点都以一种相同的方式来着色每一个点啊

然后我就用纹理的方式来改变一些主点的属性

就是这么一个意思

就是说嗯 ok 没问题

那看一下哈

其他应该没什么

基本上来说应该说差不多有同学问作业跑出来的帧率很低

正常吗

正常没问题啊

因为我们用 cpu 模拟 gpu 的这个过程没问题好

然后行

那既然是这样的话

那我觉得啊 ok 那那如果没有其他什么问题的话

那我觉得差不多啊

呃着色和材质有什么区别啊

基本没什么区别

不同的材质就是不同的着色方法

可以这么理解好吧

然后那行

那咱们今天这个就说到这儿好吧

然后这个呃下节课

然后我们给大家说这个怎么样做差值

并且把这个呃着色这部分说完

就整个 shading 部分

然后咱们再看看有没有时间说一些稍微复杂一点的话题

那么今天大家可以看到啊东西多一点

但是相对简单啊

总结起来这个这个啊

估计回去看一眼这个这个对应的这个课程课件就差不多了

好吧好吧

ok 那我这就下了啊

这个把时间交还给我们的技术秘书同学

然后同学们咱们下次再见

拜拜
