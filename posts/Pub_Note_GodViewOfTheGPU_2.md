---
title: 上帝视角看GPU（2）：逻辑上的模块划分
---


随着时代的发展，新的需求逐渐出现。来看看如何从基本的图形流水线逐步扩充成现在的样子。

![alt text](image.png)
- 前面讲的 vertex shader 和 pixel shader，都是单入单出结构。
- 它们只接受一个输入单元，处理后输出一个。
- 然而，这样的流水线有个缺失的功能。如果我们要处理的单元不是顶点，也不是像素，而是一个图元，那就做不了了。

![alt text](image-1.png)
- 这个需求催生了一个新的 shader，叫 geometry shader。

![alt text](image-2.png)
它相当于把 primitive assembler 给拆开了。Vertex shader 输出处理后的顶点之后，整个 primitive 先被送入 geometry shader，处理后往下做 primitive assembler 的剩余事情。Geometry shader 和前两种 shader 相比，有个很大的特点是，单入多出。一个 primitive 进入 geometry shader，可以输出多个 primitive。

因此，我们可以把整个三角形移动位置，或者一个三角形切成多个。它的存在，使得 GPU 可以做非均匀输出这样更加灵活多变的任务。比如第一个三角形输出 1 个，第二个三角形输出 5 个，第三个三角形输出 3 个。

另一个不同之处在于，vertex shader 和 pixel shader 都是必须的。如果你不指定，就无法串起整条流水线。而 geometry shader 是可选的。不指定就表示直接往后连。Geometry shader 输出的 primitive，不但可以进入 primitive assembler 完成整条渲染流水线，也可以把数据直接输出到内存。这个过程称为 stream output。
![alt text](image-3.png)

当然，你也可以不指定 geometry shader，从 vertex shader 直接输出。这就给了从流水线中间直接导出数据的能力。有时候我们把 vertex buffer 里的顶点处理一遍，存出去，之后反复多次使用，以减少重复计算。

但是这里有个问题，geometry shader 看起来很灵活，可以做各种各样的事情。然而一用就发现，性能奇低无比。正因为很灵活，硬件无法做各种假设来优化性能，只能实现得非常保守。尤其是把一个三角形切成多个的情况，本来是个算法固定的操作，但如果全面弄成可编程，硬件在执行之前甚至不知道你是要细分三角形，更没办法优化。

![alt text](image-4.png)
随着三角形细分这个需求逐步增加，GPU 的流水线在 vertex shader 之后加入了专门的 tessellation 功能。
![alt text](image-5.png)
它不是一个单元，而是三个。首先有个可编程的 hull shader，在里面可以指定每个图元需要被如何细分，比如内部分成多少个，每条边分成多少段。
然后有一个固定流水线的 tessellator，用固定的算法来执行细分。紧接着是一个 domain shader，根据细分的参数负责计算细分后的每个顶点信息。这部分也是可选的，如果不启用就直接往下送。

![alt text](image-6.png)
这时候有人就想了，既然 GPU 有这样强大的计算能力，那不光可以做图形渲染，还可以用做更加通用的并行计算。最早的做法是，渲染一个覆盖屏幕的大三角形，在 pixel shader 里做通用并行计算。相当于每个 pixel 是一个线程。
这样虽然能解决一些问题，但单入单出的限制仍然存在，并且仍然需要让数据通过 vertex shader、rasterizer 等整条流水线，还是存在浪费。

![alt text](image-7.png)
再加上，这种方式使得开发人员必须学习图形流水线，提高了门槛。即便如此，也仍然没有阻止 2003 年左右的探索者。这个发展起来的方向被称为 GPGPU，用 GPU 做通用计算。

![alt text](image-8.png)
这个需求，进一步催生了有硬件支持的 GPGPU。可以多入多出，可以任意读取，可以任意写入。不再需要经过那些固定流水线的单元，利用 GPU 上的计算单元进行并行计算。

![alt text](image-9.png)
这种 shader 叫做 compute shader。它独立于图形流水线单独存在，输入输出都是内存，限制比图形流水线小。整条计算流水线只有一步，使得开发难度和程序构成更接近传统，门槛低了很多。

至此，GPU 的流水线已经非常接近现在的了。能满足实时渲染和计算的各种需求。同时，GPU 的流水线也变得非常复杂。还能更复杂点吗？能啊。在 rasterizer 之前的部分，Vertex shader、hull shader、domain shader、geometry shader，它们存在的意义，就是把几何数据该变换变换，该拆开拆开，最后送入 rasterizer。但是它们都无法脱离输入的几何数据。

要渲染更复杂的物体，就得输入更复杂的数据。要解决这个问题，就必须在少量甚至没有输入数据的情况下，让 GPU 自己生成大量复杂的数据。Compute shader 的任意读写能做这件事情，但它不能接入 rasterizer。

![alt text](image-10.png)
这个需求催生了 amplification shader 和 mesh shader。

![alt text](image-11.png)
Amplification shader 负责指定执行多少次 mesh shader。Mesh shader 负责产生几何体。

![alt text](image-12.png)
这时候渲染的单元就不再是图元，而是一小块网格，称为 meshlet。当一个 meshlet 送到 amplification shader，它可以决定这个 meshlet 是否需要进一步处理。如果要的话，就往下送到 mesh shader，产生带有丰富细节的一堆图元。

虽然这两个 shader 就能取代原先那一堆，但支持的 GPU 和使用它们的程序并不多。在现在的 GPU 里，它们仍是和原先的流水线并存。

当然，需求的发展并没有停止。这些年来游戏用了各种方法，提高真实感的体验。这些方法往往互相冲突，或者用了各种限制很大的 hack。另一方面，光线跟踪这个古老但通用的技术一直没法很好地在 GPU 上应用，因为它不但计算量大，还跟基于光栅化的渲染方法有着完全不一样的流程。

长期以来研究人员一直在尝试如何用现有的 GPU 实现更高效的光线跟踪。这样的需求，终于随着 GPU 提供光线跟踪的能力而得到了实质性的发展。这时候又出现了一条独立的流水线，包含多个新类型的 shader：ray generation shader 负责生成光线，intersection shader 负责判定光线与物体是否相交，any hit shader 在光线打到物体的时候判定是否要继续往前走，closest hit shader 在光线打到物体的最近点计算颜色，miss shader 负责当光线没打到任何物体的时候计算颜色，以及与它们配合使用的 callable shader，可以进行动态调用。

后面会有一期讲解硬件光线跟踪的细节。同样的思路，也可以用在更多领域。比如，GPU 加入了计算神经网络专用的 tensor 计算模块、视频编码解码专用的模块，等等，都是独立的流水线。

这里我们可以看到 CPU 和 GPU 的第二个大区别。CPU 的目的是一个通用模块。编程的时候一路往下写就是了。GPU 则分成了多个模块，各有各的特点和用途。编程的时候就需要开发者对这些模块有比较明确的了解，在程序里安排如何使用它们。

目前的 GPU，这些流水线之间不能互相调用。如果你要在图形流水线里用到计算流水线，就得先调用计算的，把结果写入 texture 或者 buffer，再在图形流水线里读取。10 多年前我提出过可配置式流水线的构想。不但有可编程单元，连线也是可编程的。这样就能根据需要组装流水线。然而到了现在，也没有这样的 GPU 出现。

不过现在图形流水线的各个单元也有了任意输出的能力，部分解决了这个问题。长期以来，在 GPU 上做开发的人分为两大阵营。一类基本只用 GPU 的图形流水线，典型的是游戏和图形的应用。另一类基本只用 GPU 的计算流水线，典型的是机器学习的应用。由于后者在这几年非常火，从 PC 到手机到服务器，都有覆盖。

以至于有些自称做 GPU 芯片的公司，做的是所谓的“GPGPU 芯片”。只有计算流水线的“通用 GPU”。正如我在上一期里说的，GPU 的 G 是 Graphics，只有有了图形流水线，才能叫 GPU。只有在 GPU 上做通用计算，才能叫 GPGPU。只有计算能力没有图形能力就敢叫 GPU，只是在诈骗而已。没有图形能力的图形处理器，这不自相矛盾吗。

更何况，即便是在纯计算的情况下，一些固定流水线单元也可以好好利用，作为通用计算的补充。比如 rasterizer 可以作为高效的插值器，把一些数据线性扩散开来。Output merger 里的 alpha blending，也可以用来作为高效的数据累加器。这些都能进一步提高通用计算的性能。

至此，在逻辑层面，我们看到了 GPU 是什么，现在的 GPU 应该包含哪些东西。但是，如果按照这个模块划分直接去实现 GPU 硬件，会有两个巨大的问题。第一，shader 的种类那么多，如果一个程序只用到了一部分，负载不平衡，其他的计算能力不就浪费了？第二，流水线已经这么复杂，如何在有限的成本内把它安排到硬件上？

还好，这两个问题都可以用同一个方法来解决。本期我们把 GPU 逻辑上的模块补齐了，建立了在现在的需求下，GPU 应有的组成。下一期，我们将更深入一步，看看硬件层面 GPU 的构成。欢迎继续收看，再见。

