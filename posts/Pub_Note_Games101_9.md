---
title: Games101 9.Shading 3 (Texture Mapping cont.)
---

## Barycentric Coordinates

为什么要对三角形内部的点进行插值？
![Alt text](image.png)

- 已知三个顶点属性时，希望在三角形内部的任何一个点得到一个平滑的过渡。
- 以及纹理映射时，三角形内部的点映射到纹理上的哪个部分。
- 顶点的法线插值，得到三角形内部的法线。

重心坐标到底是什么？

![Alt text](image-1.png)

- 首先重心坐标是定义在一个三角形上，任意一个点 x y 都可以表示成三个顶点 a b c 的线性组合，即$\alpha a + \beta b + \gamma c$。
- $\alpha + \beta + \gamma = 1$。因此，已知两个数就可以求出第三个数。
- 且这三个数都是非负的，否则可能在三角形外部。

![Alt text](image-2.png)

- a 点可以写作$\alpha a + 0b + 0c$，所以 a 点的重心坐标是(1, 0, 0)。
- b 点是(0, 1, 0)，c 点是(0, 0, 1)。

重心坐标有个定义，它其实是可以通过面积比求出来的
![Alt text](image-3.png)

- 顶点它对面的三角形的面积占整个三角形的面积的比例

那么根据这个定义就能得到一个特殊的点，就是三角形自己的重心
![Alt text](image-4.png)

- 三角形的重心跟顶点连起来，把三角形面积等分为了三份。

### 00:15:20,16

![00-15-20](tmp/00-15-20.jpg)

这已经可以给出来嗯对吧

就是说呃大家可以去真正的算一下面积没有问题

利用我们所这个教的这个这个差成

然后如果我们就这么做的话

其实也是可以推出来这个式子的

就是说啊任意一个点 xy

然后他这个给定这个 a abc 的坐标

这个对 x a y a c l 这个这个 x b y b 这些这些坐标

然后呢我怎么算出来这个任意一个点 x y 它的重心坐标呢

它的公式就在这里

大家会发现啊

同样它就算了

alpha 和 beta

由于规定了这个他们这个 alpha 贝塔伽马的和是一

所以伽马不用算

直接剪辑出来

那这个道理就在这儿好

那么这个这就是我们说的这个重心坐标

它的一个一般的表达式

那么这个表达式当然没有任何必要去记忆它对吧

就是说它的定义我们都已经清楚了

然后对于任何的一点

我们知道我们都可以算它的中心坐标

那就可以了

那么咱们就可以用重心坐标做一点事情

### 00:16:18,56

![00-16-18](tmp/00-16-18.jpg)

什么呢

我们就可以直接应用这个这个重心坐标呀

去去这个做任何一个点

在三角形内部的点

它的颜色的差值

那么怎么做呢

呃是这样哈

大家知道任何一个点

比如说这个点是 p 点

那我可以写成 alpha 加上贝塔 b 加上伽马 c 这么一种组合的形式

同样重心坐标所告诉我们的事情

就是说如果要做差值

那么我要差值的属性

同样也应该用重心坐标去把它给线性的组合出来

那么是什么意思呢

假如说我这三个顶点有三个属性

va vb 和 vc

然后呢我这个我就可以通过任何一个三角形内部的点

它的重心坐标 alpha 的伽马

然后我把这些属性线性的组合起来

然后得到任意一个点

这个它的属性 v 这里

所以这个属性可以是任何的属性

比如说位置

比如说这个这个纹理坐标

或者说我们说 uv

然后说或者颜色像这里就是颜色对吧

然后这个呃或者是我们说的这个呃发现

或者说我们之前提到说我们我们在做这个光栅化的时候对吧

三角形打散成这个这个这个像素

然后一个像素的中心它对应的位置它的深度是多少呢

当然也是通过这个在三角形和三个顶点定义深度

然后把它插值出来

没问题

也就是说啊

重心坐标就允许我们说先算出它的这个位置的重心坐标在哪儿

然后我们在这个用重心坐标做差值好

那没问题

就是说这就是这么用的啊

然后呢这个有一点

这里就是说如果大家这个读其他的这些这些 open gl 一些文章或者干什么

然后可能会涉及这么一个问题啊

就是说这里给大家说一下这个事情

就是说重心坐标虽然不错

大家看这个应用非常简单对吧

任何一个点只要有中心坐标

我就可以插值任何的这个这个属性没问题

那么中心坐标有一个问题

也就是说啊他在投影下

在投影的变换下是不能够保证重心坐标不变的

是什么意思呢

就比如说大家现在看到这个三角形啊

假如说是一个这个空间中的一个三角形

然后呢

它这个呃我可以算出这个点

这个 v 它对应的这个这个这个重心坐标在哪

那如果我把它投影到某一个平面上去

这个三角形形状会发生变化吗对吧

然后我这个这个 a abc 和中间这个点呃

这个我都可以算出来它投影之后的这个坐标吧

那投影之后我再从这个投影之后的三角形

我再算一遍这个呃这个点的中心坐标

我会发现诶得到了一个不一样的中心坐标

这个是很有可能的事情对吧

然后然后这个这个就是说啊重心坐标它并没有一个好的性质

就是说它在投影下不变

没有这么一个性质

就是说呃如果有个三维空间中的三角形

然后你这个有一个点投影了之后

它的重心坐标就不一样了

那么也这个事情也就是告诉我们

如果我们想插值一些三维空间中的属性

我们就应该这个取这个三维空间中的坐标

就是这个 a abc

然后这个取它的三维空间中的坐标

然后取这个这个找的这一个点

比如说这个 p 中间某一个点

它的坐标也是三维的空间中中中的坐标

然后呢我来算它的这个这个呃重心坐标是多少

然后呃我再去做差值

而我不能在投影之后的三角形里面做

哎这一点是呃专门为了说一个什么问题呢

我想说的就是深度

大家想象一下啊

呃我们之前说光山话三角形呢都已经投影到这个屏幕上去了

然后它会覆盖很多的像素

然后像素都有中心

然后像素的中心的这些点呢

然后这个呃我可以知道它的投影了的三角形的哪里没错吧

然后我可以说在投影的三角形里面

对这三个顶点的这个深度的差值可以这么算吗

其实是不对的

是怎么应该怎么算呢

应该是这个呃

找到你这个像素中心点呃

对应这个三角形位置

它的三维空间中的坐标

然后我在三维空间中

然后把这个 a abc 它的深度差值好放回来

是这么一个做法

这样才是对的

那至于怎么样把这个已经投影到屏幕上

在投影回去

我们应用逆变换就可以了

这个没问题

这个大家在这个专业中会稍微碰到一点点

但不要求大家去做哈

然后这里是这个呃

我要说的一个事情好吧

这就是说在三维空间中的属性

建议是在三维空间中这里做差值

然后这个这个这个呃

在这个把这个值对应到这个二维的这个结果上面去

好吧

是这么一个事情好

那这个这里把这个事情说明白

这个根本原因啊

就是重心坐标它本身在投影操作下会发生变化啊

好那么重心坐标的差值很简单

### 00:20:46,73

![00-20-46](tmp/00-20-46.jpg)

咱们已经说完了

咱们下面一步就要说这个怎么把纹理给给应用在这个这个这个这个啊

实际的这个渲染中好吧

那么怎么应用呢

### 00:20:58,10

![00-20-58](tmp/00-20-58.jpg)

我们之前其实在提这个 shadder 的时候啊

我们已经说了这个事情呃

什么呢

就是说我这个屏幕上的任何一个采样点啊

不管是像素还是说我这个呃用 m s a a 它代表一个采样点吧

反正就是说他自己肯定有一个位置

它有一个位置

然后呢我就知道这个呃他嗯在这个位置上插值出来的 uv

或者说纹理的坐标在哪里对吧

原来纹理的坐标都定义在三角形的顶点上

现在对于任何一个点我都知道它的三角形哪儿

然后做一个差值

就用咱们刚才说的重心坐标可以算出这一个点

它的 uv 好没问题

它的 uv 算出来之后怎么办呢

在纹理上去查询一下这个 uv 的值

我就知道了

好没问题

我就知道这个对应的纹理呃

是这么个颜色

那么我们就可以拿来用这个颜色

这个颜色可以怎么用呢

呃我们可以认为哦这个纹理定义的就是这个漫反射的系数

然后这个这个这个漫反射技术

这个大家还记得在这个不联防模型里面

它就定义这个 kd

然后我就可以直接用我取到的这个 test color 纹理上的这个值去代替这个 kd

那不就等于是把这张图给贴在了这个这个这个这个呃物体上嘛对吧

并且这个物体还有这个这个风水岭能够带来的这个呃就是明暗的变化

高光这一系列的东西对吧

就是这么个意思

那这就是我们怎么样去用这个纹理映射

太简单了

任何一个点找到这个屏幕上点啊

找到文理在哪儿

然后直接查怎么用

随便对吧

那行没问题

那这就是我们说到这里

这这这就这就可以了

然后呢

那咱们这个呃进继续进展

下一步下一步是什么呢

我们看它到底出了什么问题

如果这么简单做会出什么问题好吧

咱们先看第一个问题

### 00:22:44,30

![00-22-44](tmp/00-22-44.jpg)

第一个问题我们管这个问题叫做这个呃纹理的放大

什么叫纹理的放大呢

大家可以看这里有一个问题啊

就是说哈呃如果这个纹理太小了怎么办

什么叫纹理太小了怎么办哈

假设说我们有一个三维场景

我们把它渲染出来

然后我们对着一堵墙来看

这个墙上有一幅贴画啊

然后然后就是就是这么回事

我们知道这幅墙这个墙上如果我要应用这个一个一个贴画

很简单啊

用到一张图上就好了

唉现在我问的问题是说啊

假如说我们看着一个一堵墙

然后整个分辨率我们定义这个呃渲染出来分辨率是这个 4k 好

没问题吧

然后这是非常高的分辨率

但是我们的纹理只有 256x256

唉这个怎么办

这也就是说啊

那我们看一个这个很高分辨率的强

然后这个任意一个点

他去查这个纹理的时候

他会查到一些非整数的值

对不对

也就是说啊纹理太小了

纹理就会被拉大

被拉大了

自然就会看到这样的现象

### 00:23:43,63

![00-23-43](tmp/00-23-43.jpg)

就是说啊这个呃纹理本身太小

首先呢它是一个问题

正常情况下

如果大家涉及到打游戏啊或者干什么

大家都会避免这个问题

就是说这些游戏的制作者

他不可能会让你说这个这个有一些很重要的一些地方

然后他用了一个很低分辨率的纹理

但是啊这种情况普遍意义上还是会发生的

也就是说这个嗯嗯就是我刚才说的例子啊

看着一个高清的一个奖

但是它上面贴的这张图却很低级

那怎么办呢

那很简单

对于任何的这个这个呃墙上的一个点对吧

一个像素这一个点我都可以找到它对应的这个纹理上的一个位置

然后这个位置可能不是整数

不是整数

怎么办呢

那咱们就把它给这个这个 around 成整数

就四舍五入成整数好吧

我把它给这个

比如说零点点四

我认为是零啊

0.6 我认为是一

那这样的话呢就相当于是呃在一定的范围内

就是我们要查找的是呃一个相同的这个纹理上的像素

然后纹理上的像素它是有个名字的

叫 taxi

然后中文叫文理元素或者文素啊

反正这个挺别扭

然后我就管它叫 pixel 和 txo

这样来说吧

pixel 呢就是我的这个生成的这个画面上面的一个像素

然后 text 就是纹理上的一个像素

那么我们现在可以看到啊

一个 pixel 一个像素

它可能说在一定的范围内

然后呃然后就是说它周围的很多像素吧

比如说 3x3 或者 5x5

很很多像素它都会被映射到同一个这个呃 txt 上去

这是因为纹理太小了对吧

所以如果我们去做一个简单的四舍五入

我们会得到这么一张图

然后呢我我们不希望这样对吧

这看上去一个一个格子很难看诶

我希望说能得到这个这个中间或者右边这样的一种效果

也就是说我引入点模糊没什么问题

但我希望最起码得到结果是稍微连续一点

这也就是说明什么呢

这就是说我这个当我在查询啊

查询这个纹理的时候

如果你给我一个非整数的坐标

那我应该如何得到它的值

对不对

这就是我们要说的这个呃这个双线性差值它的概念呃

### 00:25:44,63

![00-25-44](tmp/00-25-44.jpg)

### 00:25:49,0

![00-25-49](tmp/00-25-49.jpg)

所谓双线性插值

咱们看一看啊

我我刚才说这个呃我们的一个高分辨率的这个这个屏幕

它上面一个像素里面的中心呃

它映射到了一个非整数的这个位置上

而我们现在看到的这个 4x4 的格子是 taxo

就是像就是那个那个纹理啊

然后它映射到这个位置

那我想知道好纹理在这个红点处它的值是多少

那么我刚才说啊

有一个最简单的办法找离它最近的嘛

就找这个点

那么说如果这个红点在这里

那也会找到这个点

那整个这一块可不就显示相同的颜色了嘛对吧

然后然后就会形成形成一块一块

现在我不想

现在我想怎么做呢

### 00:26:24,50

![00-26-24](tmp/00-26-24.jpg)

我想这么做诶

我想知道这个这个像素的中心会映射到这儿

我可以找他临近的这么四个点对吧

临近的四个点我总可以找得到

然后临近四个点找到了之后呢

然后我们还怎么办呢

我们在做这么一个操作

### 00:26:37,43

![00-26-37](tmp/00-26-37.jpg)

就是说啊呃我们知道这个屏幕空间我们定义过了对吧

从左下角开始向右向上对吧

然后同样道理

这个四个点它总有个左下角

然后你的这个红点你可以找到说这个离左下角

它的水平距离和竖直距离啊

大家看这个水平距离

我们管它叫 s

然后竖直距离管它叫 t

这个 s 和 t 肯定都是 0~1 之间的

为什么呢

因为这两个像素或者两个 txt 之间

两个 txt 之间它的距离是一

如果这样认为的话

那这个呃这里没考虑那个叫什么 uv

它的定义是 0~1 哈

咱们就以这个呃一个一个像素这个单位为一好

那也就是说这个长度是一

那么对于它投影出来的这个分量水平的这么一个距离呃

就管它叫 s 一定是在 0~1 之间

t 也一样好

咱们现在找到周围四个点投影出这么两个这个长度好

下面一步怎么办呢

下面一步啊

### 00:27:28,20

![00-27-28](tmp/00-27-28.jpg)

我们定义一个操作叫做线性差值

线性差值太简单了

什么意思呢

就比如说这个有两个

你有两个不同的值吧

在定义在两个位置上

然后呢如果我定义一个 x 是 0~1

我认为这个这个 x 等于零的时候

x 在这里

x 等于一的时候

它在这里

那么我问 x 等于 0.5 的时候在哪啊

它应该在中间对吧

x 等于 0.9 的时候在哪啊

应该靠近这个这个这边对吧

然后这就是这个这个线性差值

然后大家看这个例子啊

linear interpolation 就是它的定义简称 lp 就是 linear interpolation 的意思

线性差值

线性差值什么差值

这个 v0 和 v 一分别定义在位置零和位置一上

所以 x 是一个 0~1 之间的值

那么咱们看看 x 等于零的时候

然后我们可以看到这个值等于 v0

没问题

x 等于一的时候

然后这个定义啊就是 v0 加 v 一到 v0

那就是唯一

所以 x 等于一的时候是呃只是为一

那 x 等于 0.5 的时候

大家可以发现啊

正好是两者中间

所以他就做了一个这么一个线性差值

如果咱们定义这么一个操作的话

那行咱们现在就已经不用关心具体线性差值的这个公式怎么做了

咱们就直接可以做一个差值什么呢

### 00:28:37,3

![00-28-37](tmp/00-28-37.jpg)

大家可以看到这两条线水平的这两条线啊

就是左下角右下角

然后我用 x 可以做一个线性差值

然后左下角这个点有一个颜色呃

这个点有一个颜色

然后呢它这个中间的位置

这个我就知道它离左边距离是 s

然后我就可以用这个 s 来对这两个点它的颜色进行一个差值

好

我得到一个这个黑点

同样道理

我对上面这条边对左上角和右上角这两个点

这两个既然定义在这个纹理上

这两个有两个不同的颜色

然后呢我也知道哦

它水平距离离左边 s

然后我就用这个 s 去插值这个左边和右边诶

我得到另外一个差值出来的值

诶

那我现在把这两个这个这个差值完成了之后怎么办呢

我最后想得到这个红点处的值啊

那大家可以看到这个应该已经可以想象的出来了

对不对

然后这个我再做一次数值的差值就可以了

### 00:29:30,60

![00-29-30](tmp/00-29-30.jpg)

我把这个竖线上

我因为这两个黑点的值我已经算出来了对吧

我数值这个方向上我可以看

比如说这这一个点

然后这一个点

然后我要插值出在 t 这个距离上的点

为什么是这个这个 t 呢

是在这儿啊

t 这个数值的距离呃

这是这段距离是 t 然后我就用 t 来差值这个点和上面这个点

就刚才差值出来的两个点好

我再用 t 把这两个值插值出来好

那么大家就会看到好

这里我做的呃两两种吧

差值第一种叫做这个水平方向的这这两个点

两对点分别进行一个差值

然后我得到两个点

然后我在竖直方向再进行一个差值

那我就可以得到竖直方向这一个值没问题

那大家可以看到这个点的颜色

现在就综合考虑了它周围的四个点的颜色

并且呢咱们假设一下这个红点啊

如果非常靠近这个 u00

你得到的结果就应该和这个 u00 很像

那如果说这个这个红点它在正中间

它就应该是这四个点的这个平均值没问题

这里就是说这两个通过这两步水平和数值的这个差值诶

我就可以得到一个平夸的过渡

在这个在这么四个点围城这个区域内

就可以得到任意一个点

它的平滑过渡的颜色是多少

哎所以说这是一个不错的做法

所以呃这个就是说我做了两趟差值对吧

水平一趟

数值一趟

然后我们就管这个方法叫做双线性插值

因为做了两趟线性

当然我没说两次哈

大家知道这个水平上做了两次

是不是让他做一次啊

就是指水平和数值都要差值

我们就管它叫双线性差值

当然有同学问这里这方向能不能反过来

能没任何问题啊

这个大家可以这个手推一推这个公式

你就会发现先数值在水平一样的

没什么问题好吧

那道理就在这儿哈

咱咱们把这个这个这个呃思路先先这个搞清楚对吧

我们有一个很小的图

然后呢这个我要把它放大

我要查询它在任何一个这个非整形位置上的这个值是多少对吧

我希望它平滑过度

平滑过度怎么办

找连续的

找这个最近的四个点

做一个这个双线性差值

就可以得到平滑过渡的结果

### 00:31:38,30

![00-31-38](tmp/00-31-38.jpg)

那么这里中间这幅图呢就是大家看到的这个呃双线性插值的结果

而双线性差值大家可以看到啊

效果挺不错的对吧

然后呢这个比这个我就什么也不考虑

我直接把这个四舍五入坐标做这个

弄到这个整形的这个这个 txt 的坐标上

然后我就这个直接找他

我就会发现很多像素都会被映射到同一个 txo 上去

然后就会出现格子

现在没有对吧

没有挺好的

但是呢就是说啊这个这个双线性差值它当然也有它的问题

就是说它的质量和一些更高级的方法

它有这个呃这个还是差一些

比如说大家看右边这幅图

右边这幅图呢叫做这个这个这个这应该怎么说呢

这是嗯我想了想哈

这个英文好吧

我们就管它叫白 cubic 吧

就应该是双向

这个这个三次的差值

咱们只能这么翻译啊

就是这这翻译不好

那咱们就用英文吧好吧

双线性叫白 linear

然后这个叫做叫做 by cubic

by cubic 呢

其实其实这个道理也好理解

他取的不是周围的这个临近的四个哈

他取的是这个你任意一个点取周围临近的 16 个

然后这 16 个也是做这个数值的和水平的这个差值

只不过每次用四个做一个这个三次的这个差值

不是用线性的这个差值好吧

这里简单给大家提一下

那么这个这个 by cubic 这个这个大家可以想象

它肯定比把 linear 的运算量要大

它取周围的 16 个嘛

把 linear 我只用周围的这个四个嘛

然后它它这个运算量大

但是它带来更好的结果

不知道大家这个图里面啊

这个经过了这个直播之后还看得清楚

比如说大家看这个眼角这段这段看得特别清楚

就是说双线性插值在这里还可以看到一定的锯齿状啊

然后但是在这个 by cubic 差值这块

大家就看不到什么太那个这个这个差值了对吧

然后这个好吧

咱们呃大概就是这么个意思啊

然后大家这个又一次体会到这个事情

在这个图形学里啊

呃我们频繁遇到这样一个问题

对就是说这个好的质量的东西往往都伴随着这个更高的这个开销

然后呢这个大家通常会提出这么一个东西

后来再去这个再去想说

我怎么样把这个开销降下去

我又能得到好质量

这是基本上一个这个这个提高的一个思路哈

这个呃就简单跟大家说一说

这是关于这个纹理的放大问题好吧

这就说到这儿好啊

ok 然后呢这个啊看不清问题也不大啊

### 00:34:06,40

![00-34-06](tmp/00-34-06.jpg)

基本上来说这个双线性效果已经不错了

然后这里呢呃我们刚才已经提到了

说如果这个纹理挺小

那我看着一个这个很大的一个平面

然后这个图这个纹理肯定要被拉大

会出问题对吧

那么我们现在想另外一个事情

如果这个纹理太大了会怎么样对吧

这是另外一个问题

但是大家这个这个想一想

这个这个纹理大了有什么问题吗

小了我当然需要这个差值出来

大了我不需要啊

到了怎么会有问题呢

答案是这个纹理大陆的话反而会引起更严重的问题

而这个就是就是说和这个这个嗯这个这个这个第一想法不太一致

对不对

这个大家会觉得文理大的话什么信息都有啊

这怎么会引起什么问题呢

啊咱们来看一看好吧

### 00:34:53,26

![00-34-53](tmp/00-34-53.jpg)

就比如说啊大家现在看这么一个这个平面

这个平面呢往这个远处延伸

大家可以看到前面这个地平线对吧

然后这个这个平面呢上面贴了一张图

这个纹理纹理是什么呢

是一个格子

是这个格子水平竖直的啊

这样这样贴上的

然后咱们从某个角度上看过去诶

我们会发现啊

这个近处看到格子挺大的

然后远处这东西挺小的

没问题

我们做透视投影嘛对吧

这个肯定是这样的

远处的格子会挺小

那么大家可以想象一下

如果我还照之前的操作啊

简单的这个应用纹理怎么应用来着

像素的中心对吧

找这个纹理坐标

然后求出这个纹理坐标上的这个值是多少

我们已经知道怎么差值了对吧

所以任意的坐标都知道

然后然后它的值啊

然后我们把这个值写回这个像素

那如果说我们要做这个这个简单的操作会得到一个什么东西呢

### 00:35:42,83

![00-35-42](tmp/00-35-42.jpg)

我们会得到这么一个这个这个呃

### 00:35:43,73

![00-35-43](tmp/00-35-43.jpg)

看上去非常非常不对的一个一个东西对吧

然后大家看到什么了呢

大家看到了很熟悉的东西叫摩尔纹啊

远处摩尔纹

然后近处当然大家看到了很严重的锯齿

所以说大家这个从这个纹理上大家就会看出呃

和之前的一个现象完全完全一样的问题对吧

就是走样这个走样问题

那咱们这个又遇到他了

那么这个问题到底是怎么来的呢对吧

然后这我们怎么解决呢

这就是我们下面要探讨的问题好吧

然后这个呃大家可以看到这个原处这个是越来越差越来越差

从这进出多少还能看到远处越来越差好呃

### 00:36:28,73

![00-36-28](tmp/00-36-28.jpg)

然后这里问题在哪儿

那咱们分析一下

为什么呢

因为近处其实一个像素来说啊

它这个覆盖的这个呃这个纹理上的一个区域其实相对较小

就比如说像这里

就像这里覆盖纹理上的区域相对较小

然后在远处那一个像素

它其实这个覆盖了一片纹理

覆盖了一个很大的一个区域对吧

那也就是说啊

这告诉我们屏幕上的这些像素

它们覆盖的这个纹理上的区域大小是各不相同的

那如果说对于一个这个像素

它覆盖纹理上的一个区域挺小好

我用这个像素的中心查询一下它的值啊

我知道啊

这就是这个像素所覆盖区域的这个纹理的值

我可以近似的这么认为

没问题

可是如果一个像素

就比如说以刚才为例

那些像素覆盖了纹理上面的很大一块区域

现在我还用它的中心

我去查这块区域

我说好

我就看这一个点

这个点的值我就认为是整个这一块区域它的平均值

那这个呃听上去就首先就不对对吧

就是说我用这一个点如何能代表这么大一个区域

它的这里面这些不同的这些点

这些颜色的变化对吧

这是代表不了的

就是说当这个像素覆盖的这个纹理的区域大的时候

我们就不能这么简单的去采药了对吧

就是说中间用用它的这个这个像素中心去采样了

那这就是我们遇到的问题

那么这个大家自然而然就会问这么一个问题对吧

### 00:37:52,83

![00-37-52](tmp/00-37-52.jpg)

之前我们解决这个这个锯齿怎么解决的来着

我们做这个抗锯齿对吧

我们引入了这个这个这个呃这个 m s a a

或者说我们说超采样的都是差不多一个一个概念

怎么做的呢

其实就是说我一个像素

我用更多的这个呃样本对吧

不同的位置像在相同内对吧

我去感知这么一个变化的函数

没问题

这里我们同样也可以这么做

比如说大家现在看到右边这幅图哦

### 00:38:21,16

![00-38-21](tmp/00-38-21.jpg)

如果我这个每一个像素里面我用 512 个点呃

这个这个采样点

然后我把这些点都给这个呃对应的位置

在这个管理上算出来

然后取出的值

然后对于远处的一个像素

比如这个像素

它里面有 512 个点

我取它们的值的平均

然后就可以得到一个不错的这个结果

没有问题

说这个超采样能得到一个很好的结果

没问题

但是同样道理对吧

我们用很多的这些这个采样点

肯定会让这个呃整个算法变得特别慢

那咱们不希望这么做对吧好

那咱们回来看这个理论上到底我们应该如何分析这个问题

那首先我们遇到的是一个这个这个走样的问题

### 00:39:01,96

![00-39-01](tmp/00-39-01.jpg)

那走样是怎么来的呢

这个大家还记得吧对吧

就是呃信号变化过快

我们的采样的速度跟不上它或者采样频率对吧

那么这个在这个问题上如何体现

就是说我们在这个纹理过大这个问题上如何体现这个采样这个概念呢

很简单

什么呢

就是说当这个纹理特别大的时候

你的一个像素里面像素内部哈

这块纹理它是在一直在变化

然后也就是说在一个像素内

它的频率很高

可是你只用了一个采样采样点去采样

它那肯定是不行对吧

那么我们回到之前我们说的这个信号的这个概念上来

这个不需要任何公式

咱们想就能想明白一个像素内它有着非常高频的信息

我希望把这个像素内的值给这个这个重构出来对吧

那我就应该需要一个更高频的采样方法

这就是为什么说我们需要这个这个非常多的这个这个这个采样点

在一个像素内对吧

我们用这个超采样的方法对吧

然后我们一个像素内取好多个点采样这个这个纹理上的这个知识

并且平均起来

这就是我们要做的对吧

然后然后就是说这个这是一个这个沿着以前的这个方法

然后咱们做了一个一个呃简单的一个思路分析对吧

那当然我们不想用这么多这个这个太阳点

那怎么办呢对吧

因为我如果一个像素真的就用 512 个采样点的太多了

咱们怎么办呢

我们这里提供另外一个完全不一样的思路

### 00:40:28,40

![00-40-28](tmp/00-40-28.jpg)

什么思路啊

行采样会引起怎样

对不对

那咱们不采样怎么样对吧

如果我们可以避免采样

那什么叫避免采样啊

我原本说啊

这个大家还记得刚才那些这个像素会在这个纹理上覆盖

很这个很大的一块区域

那如果我立刻就可以知道这个区域里面它的值的平均是多少

我我不采用

我如果立刻可以知道这个平均值是多少

那就很好了

对不对

诶

那如如何我们才能知道这个给你任何一个这个呃这个区域

比如说咱们看这里啊

### 00:41:04,6

![00-41-04](tmp/00-41-04.jpg)

还是刚才这一页

任何一个区域你立刻可以得到它的平均值对吧

我们要解决这么一个问题

那这就是我们之后要说的这个所谓 mile map 这么一个概念

当然在这之前我们先在这儿停一下啊

这里就是说我想这个说一点

就是这个问题其实是一个算法问题

这是在这个数据结构啊

在这个计算几何啊

在这个呃很多领域上都得到了一个应用

那那就是说啊这个是什么问题

就是说点查询问题和范围查询问题

然后点查询很好理解

比如说这个以这个 texture 纹理为例

给你一个点

它的值是多少

咱们刚才说双线性差值

说什么都是这个这个道理

这叫点查询

另外一个呢咱们所说的是咱们不做采样对吧

给你任何一个区域

你立刻可以得到它里面内部的平均值

这个就叫做范围查询

叫 range query

range query 是一个这个是一个这个呃经典问题

然后呢就是说在这个算法上

这个呃有各种不同的这个方法去研究它

当然在图形学上大家找了一个非常非常近似的

但是很快的方法来做这个范围查询

另外多说一句啊

范围查询可不只是我们用的这一种应用叫平均查询

我们要求这个范围内的平均值

这是我们要的结果对吧

也有些范围查询是要查范围内的最大值和最小值

这个问题就完全不一样好吧

然后然后就是说有很多不同种类的范围查询啊

那咱们这里就就说到这儿

那说白了就是说现在给你这个这个呃一个图上面任何一个区域

你能不能快速地告诉我它的平均值是多少

这就是我们要的这个这个结果

### 00:42:36,56

![00-42-36](tmp/00-42-36.jpg)

然后呢我们以这个实际的渲染的这幅这幅图为例

比如说我们想渲染这幅图

那大家知道这块比如说这个窗台这块啊

离大家挺近的

那也就是说这块一个像素覆盖的区域

这个范围相对较小对吧

在这个纹理上覆盖的区域相对较小

那么这块区域离我们很远

那这一个像素其实它覆盖在纹理上

它应该覆盖的非常大对吧

然后假设说我们用的同一个纹理哈

然后好

那么就是说这个不同的像素有不同的这个呃在纹理上覆盖的大小

那所以我这个范围查询应该能够查询任意不同的大小对吧

那也就是说呃对这就是刚才说这两个区域上啊会有各种不同

### 00:43:18,76

![00-43-18](tmp/00-43-18.jpg)

然后呢这里我们引入了一个概念

就叫做 mp map

map

map 是一个在图形学上得到一个广泛应用的经典概念

那么他能干什么

这里现在就可以告诉大家

它允许大家做范围查询

这正是我们要的东西

对不对

诶

但是我这里有三个这个不同的词

这里啊第一范围查询做的快 fast

然后第二是 approximate

也就是说他做的范围查询是不准的啊

首先来说做的范围查询是不准的

它中间涉及到近似

但是因为它快对吧

大家希望的东西能够跑得越这个越快越好

然后另外一个它可以做什么

它它可以做的是仅仅是方形

特别只有是正方形的范围查询

这点跟大家说清楚啊

就是说 mile map 是可以做范围查询

但只能做近似的正方形的范围查询好吧

那咱们把这个事情说明白

然后其他要不是正方形不行

那是用什么呢

马上马上咱们再说好吧

咱们回到 mile map 这个概念上来

那什么叫 mile map

### 00:44:16,23

![00-44-16](tmp/00-44-16.jpg)

maple map 非常简单啊

这个 mirap 大家可以看它这个拉丁语里来的这个东西啊

然后就是说这个 mp 的概念

其实就是说这个这个这个很多不同的小的东西对吧

这个合在一块儿

那这个对应到咱们图上

其实 mapmap 呢就是从一张图生成一系列图嗯

那咱们看看什么意思啊

比如说大家有张纹理

这张纹理呢假如说原始的这个纹理

我们管它叫做这个第零层纹理

使得每一层都是这个上一层

这个呃都都都是这个这个呃比如说第 i 层啊

都是第 i 减一层

它这个图缩小一倍

就是分辨率缩一倍呃

呃其实应该说是缩小到一半啊

这样说的比较明确一点啊

就比如说这个大家之前拿到的一个这个纹理

它的分辨率是 128x128 对吧

那么呃这这是第零层

那第一层怎么办呢

把这个图分辨率缩小一半

那也就是说我要我把这个图重新表示成

这 64x64 的一个一个图

大家可以看到啊

已经可以看到这个不同的这些这些像素被拉大了

对没问题没问题

然后这分辨率低了嘛对吧

这是为了显示哈

就是说大家看到这里它们的大小还长得一样

这只是为了显示告诉大家说现在它的分辨率是多少

其实分辨率已经小了一半了啊

然后第二层在第一层的基础上再砍一半

就变成 32x32

第三层在这个这个第二层基础上再小一半

然后这个这个这个呃 16x16

那做到什么时候呢

做到最后还剩一个

还剩这个这个这个一个点对吧

那大家知道这个总共有多少层呢

既然每一次把一条边砍了一半

那它的层数就是 log 2 这个呃这个这个分辨率对吧

那就总共有那么多层

就是 log 层好

那没问题

那我们这个可以提前计算它

这就是关键

就是说大家拿到了一个这个纹理之后

那我先把这个纹理处理一遍对吧

在渲染之前

我先花点时间把这些生成

把这些对应的 mmap 都生成

那么对应到 mini map 里面呢

### 00:46:16,76

![00-46-16](tmp/00-46-16.jpg)

然后这个这个我们生成的是什么

这个生成的是这么一个东西

就是第零层是原始的图像

然后上面这个小小了一倍

小了一半

然后这个又小了一半

然后一直到上面

所以呢在这个计算机视觉界啊

大家不管这个叫 mile map

管它叫 image pyramid

叫叫这个图像金字塔啊

一模一样的概念啊

没有任何问题

就是说这个呃这块儿这个这个就是就是说给你一张图

你要生成更多的图对吧

然后这个每一层我这个比如说第零层

第一层

第二层我管它叫 d 等于零

d 等于 d2 啊

就这么一个安排方法

那么现在呢我有一个问题对吧

在这个在这个应用 map map 之前

先问大家一个概念

诶

我们原本有这么一张图

### 00:47:00,36

![00-47-00](tmp/00-47-00.jpg)

然后他占据了一定的存储量

那咱们生成了那么多其他的这些图

那么总共我们引入了多大的这个额外存储量呢

就是说就是相比于原本的这个

如果认为原本的这个存储是一

那么我们算出来那么多不同的层数

我们引入了总共引入了这个多大的这个额外存储量

就是说比原来多多少对吧

是多少呢

哈哈哈哈

这里大家可以猜一猜对吧

这个很显然不是八倍对吧

嗯比如说这里这个这张图

因为其他图都是越来越小

越来越小对吧

然后我这里有一张图

我不能说我的这些图

其他图都跟他存储量一模一样对吧

就是 log 它的这个边长数倍

那肯定是不对的对吧

肯定比那个小小多少呢

大家可以算

这是一个级数求和的问题

对不对啊

大家想一想啊

这每每次边长砍一半

也就是说每次存储量是原本的 1/4

那就是 1+1/4

加上这个 1/16

再加上这个 1/16x1/4

比 1/64

再加上一直把它加上去

得到的结果是多少

43/3 分之四是什么概念

就是说原本的图存储量是一

我只是多了 1/3 的存储水源

也就是说啊所有这些其他的层这个把它们都给加起来

它们的存储量都加起来

唉我只是原来的存储量的 1/3

这个事情很不可思议

对不对

然后就是说这个这是这是一个这个很有意思的一个一个事情啊

这个当然等比数列这个都好算啊

没什么问题

这里呢这个嗯我想一想哈

其实有一个更简单的办法算这个我这里简单给大家提一句吧

如果大家有兴趣的话

大家看这张图啊

看这张图

但是我这个这个怎么理解呢

就说我假设说我把我原原本的这个图啊复制三份

我们不是想说这个这个总共的存储量

额外存储量是多少嘛对吧

额外存储量是多少

呃也就是说啊这个如果我把所有的每一层的这个存储都乘以三

那肯定不影响最后结果对吧

我要的只是一个比例好

那没问题

那咱们假设说我把原原图放在左上

右上左下

也就是说这三个都是第零层啊

这三个第一个第二个

第三个

这三个都是第零层

那么我剩下右下角这一块

我知道我可以把第一层也复制了三份给填在这

这和这个位置好吧

然后又缺了一个右下角

这个右下角我又可以把第二层这个左上右上左下填上去诶

然后我就可以一直填一直填一直填

我不管多少层

我最后得到一个极限是什么呢

得到极限就是整个这个块儿大小

那么咱们回到这个之前的这个概念上来啊

这个每个图我都复制了三份对吧

第零层

第零层

第零层

其他全都不是第零层

也就是说额外的存储是多少呢

就是原本的 1/3

对不对啊

这是一个这个很很很精妙的一个算法

这个当然了

前提是你要是不知道这个额外存储是 1/3

你也构造不出这种这种这种这个理解方式

对吧啊

这个方便大家理解啊

这也就是说呃对的没问题啊

就是说 mmap 仅仅是额外的 1/3 存储

所以非常好

那么我们 mile map 刚才说什么来着

### 00:50:09,73

![00-50-09](tmp/00-50-09.jpg)

我们要用 mp map 做一个近似的

在一个正方形区域内做范围查询

我立刻要得到这个这个区域内的这个呃平均值是多少

诶那这个这个就有同学问了对吧

那我怎么知道我上来要查询的区域

这个事有多大对吧

它长什么样

它是不是这个都可以映射到一个这个这个这个这个纹理上的一个区域

对吧

那这个区域我怎么得到呢

那是这样哈

就是说有一个近似的办法很简单

大家可以看这里哈

就是说我们认为一个三角形它覆盖了一堆这个采样点

然后这些采样点呢比如说我们看这个蓝色点

它有一些它的这个邻居

红色点呢也有一些它的邻居

那很简单

我想我想算啊

这一个像素就是说比如说这个红点它所占据的这个像素

它的覆盖面积

那我怎么算呢

我可以取他的这个他自己的中心和他邻居的中心

分别都投影到这个呃纹理上 n 去对吧

那我就是说你看这个红点那会映射到这个红点

然后这个上面这个红点会映射到这个红点

然后右边的红点会映射到这个红点

那然后呢我就可以做一个近似

做什么近似呢

### 00:51:21,53

![00-51-21](tmp/00-51-21.jpg)

大家可以看啊

大家可以看这个点到它上面这个点

它的距离其实差不多

这就是一个像素

没问题

然后这个点到它右边的这个距离

这是在屏幕上啊

这是 pk 总

这是像素

然后它到它右边距离也是一个像素

那么我就知道哦

他们这三个点分别映射到纹理上去

它会占据多多长的这个距离啊

这个会占据多长的距离

然后就是说这个是可以求出来的

然后这里公式这也也已经写的清楚了

没问题啊

这里看着很复杂

其实完全不是这么复杂啊

这个这个呃其实目的就是为了求说

这个我把这个这个它上面一个点扔到这个这个呃纹理上

然后它会在哪个位置

然后我我这个比如它右边这个点呃

扔到纹理上会是哪个位置

求它们的长度

求它们的长度之后

大家会发现啊

这个长度或者说这个是这个这个点到它上面这个映射过去的点

它这个长度其实就能够基本上来说近似这个像素

也就是说这个粉红的这个这个区域

它那个所在这个纹理上

它的边长好吧

然后这是什么意思呢

这个这个大家看这么一个框对吧

### 00:52:26,93

![00-52-26](tmp/00-52-26.jpg)

也就是说我可以用这么一个正方形框

来近似这么一个这个不规则的区域对吧

然后这里呢大家可以想象成什么呢

就是说这里相当于再做一个这个这个这个 finite difference 啊

就是相当于在做一个这个这个怎么说来着

就是说我要算出来这个他们的微分

就是就是就是说呃如果我在这个像素上这一个呃就是屏幕上一个点吧

呃移动某一个距离

往哪个方向移动某个距离

我要知道他在这个这个呃纹理这种空间上

它要移动多少距离

就是这么一个概念

它算了其实相当于一个简单的一个微分啊

但是我们刚才说就完全没按微分这个理解

咱们就把这个对应的这个右边和上面的点给投影到这个纹理空间上

求他们对应的这个这个长度是多少

然后这两个长度呢当然会可能会有所不同对吧

呃简单起见

咱们就取最大的就可以了

比如这样两个这段叫 l1

就是这个这个点和它右边这个点他们映射的这个呃纹理空间上的距离

那么这个点和上面这点映射的纹理空间距离叫 l2

那么两个取一个最大值

我就可以近似的得出啊

如果我假设在纹理空间上仍然是一个这个一个像素

仍然会映射到一个这个这个这个这个呃矩形区域和正方形区域

那它的边长应该是多少啊

就是这么个意思好

那么这就是这个这个这个正方形区域

咱们怎么近似得到哈

当然有同学说

那我能不能拿这个正方形的

这不就是说这个像素啊

他不是有四个顶点吗

我把四个顶点都扔过去

然后我在这个用这个映射过去的四个顶点

然后我来算出四个边长

我在算这个这个这个它这个边长的最大值可以绝对可以没问题

反正都是进四对吧

就是说我们用这种方法也是进四

那么这里不是关键

这里的关键是当我们可以把任何一个这个像素覆盖的区域

近似成为一个正方形的时候

那这个正方形它的查询我要怎么做

我如何去根据我的这个之前预计算好了的 mmap 对吧

我来查询说这个这个像素哦

不这个区域呃

边长是 l 的区域

它的值的平均值是多少

那这里就是说这个 mp map 聪明的地方了

比如说啊我问大家这么一个问题

如果这个区域的大小就是 1x1

就是一个像素

那我是不是就可以在最原始的这个这个图

没有做过 mapmap 的最原始的那张那张纹理上找对应的这个像素

然后这是它的值对不对

那如果说我这个区域它的大小是 4x4

那我就知道这个区域一定在第二层上会变成一个像素

为什么呢

大家可以想象这个区域的大小是 4x4

那么这个是是指是指在它这个最这个原始的那个那张图

它上面是 4x4

那么如果经过第一层 map map 之后

这个区域会变成 2x2

然后经过第二层之后

它会变成这个这个 1x1

也就是说这个区域 l 乘 l 这么个大小

它在这个 d 等于 log 2 l 在这一层上一定会对应到一个像素去

也就是说我要通过这个区域我求出它在第几层会变成一个像素的大小

然后我就可以去查那个像素

我就可以立刻得出这个区域内的平均值是多少了啊

就是这么一个意思对吧

然后然后就是说我们是这么做的

这就是为什么啊

就是说我们在第几层去查询它呢

是在 d log 2 l 层对吧

然后就是这么一个一个概念

那么大家可以看到啊

### 00:55:53,43

![00-55-53](tmp/00-55-53.jpg)

我们这个如果说我对于每个像素我都算它会投影到这个呃纹理上

对应一个多大区域

然后我把它这个这个多大区域给这个计算成

我要在第几层 me map 上去找这个这个平均值诶

那我就可以做一个这个可视化

大家可以看到哦

这里离我们非常近非常近

然后这里颜色就非常非常深啊

然后这个就是说我要在很低的层去查询它

没问题对吧

因为这里这个离我们近

能看到很多细节

我就应该在最低层去看看

然后这个这个地方呢大家可以看离离我们特别远

离我们特别远

为什么呢

因为这个地方一个像素覆盖的区域就非常大

一个像素才可能会近似这一个区域

对不对

那我们这样想

然后这里呢大家会看到呃

基本上来说它是颜色有一个渐变

但大家会发现一个问题

这个变化好像不怎么连续啊

就是说我在第零层差

然后我突然发现 a 我到这儿

a 我应该在第一层差

然后我突然发现到这儿唉

我应该在第二层差

对不对

因为怎么算的呢

因为我们之前只算了离散的若干层啊

对不对

我们只算了这个第零层

第一层

第二层我们可没算 1.5 层是什么

那怎么办

对不对

那我们肯定不希望说它这个在不同这个这种不连续的层上查询

那这样的话查询到的结果保不准在这个地方就形成了一道缝

不连续

那么不希望这样怎么办呢

我希望它真正的就能查询

比如说第一连八层是什么东西

怎么办

那大家有第零层

大家有第一层

那怎么做

第 1.8 层呢

哎 1.8 哈

有第一层和第二层啊

然后你要查第 1.8 层对吧

那怎么做呢

很显然大家又想到这个概念了

差值对吧

差值就行了

### 00:57:37,30

![00-57-37](tmp/00-57-37.jpg)

那比如说我这个我要查这个 1.8 层

那没关系

我先找第一层

我再找第二层

然后这两层内部我分别用这个双线性差值

把这个我对应的这个这个在这两层上的这个查询

我先把它做出来

做出来之后怎么带对吧

做出来我们把这两个双线性差值的值合在一块儿

我就可以这个在这个层与层之间再做一次差值

然后然后这个差值就是就是说大家可以看到又不是水平

又不是数值

它是层与层之间的诶

那我做了这个

这可不是第三这个这个这个不同的差值嘛

也就是说我总共做了三三步差值

对不对

然后也就是说这个呃双线性的

然后在上面再加一个这个线性差值

我们管它叫三线性差值哦

这里就是说我这个纹理

这样一来我就可以呃计算离散的这个 maple map 层

不管它是整数还是还是浮点数

我都可以查他这个值是多少

那么现在大家可以想啊

在这个纹理的内部

我不管它是整数坐标还是非整数坐标

我都可以这个双线性插值出来的一个平滑过渡的值

在层与层之间也可以说是也可以插值出来一些这个这个这个连续的值

那这样一来就没有任何死角了

对不对

对于任何的这个查询的区域

然后我都可以这个呃通过三线性差值

然后做一次查询就可以得到这个区域

它所覆盖的这整个一个这个这个这个面积呃对吧

是这么一个意思呃

覆盖的这个这个这个面积内的平均啊

这个意思好

这就是三线性插值

那么这里呢呃首先是这样啊

先给大家说一下

这个今天看来又没办法了

这个我们还有一块内容没说呢

然后这个我尽快我尽快啊

这么回事

这个三线性差值呢

它这个非常有用

这就是为什么在这个各种各样的这个游戏啊

或者各种各样实时渲染中间的应用

它得到了一个非常非常广泛的应用

这个这就是这个这个因为呢因为他可以得到一个完全连续的一个表达

对吧

在这个层层与层之间和层内部都是连续的

没问题

然后三线性差值这里面呢这个这个嗯嗯这个叫什么本身的开销呢

无非就是说这个呃做两次查询

然后做一次这个差值

所以说本身开销挺小

这就是为什么说这个现在游戏或者什么东西

默认都是有这么一项这个选择的

然后呢大家可以在这个呃可以试一试打任何的游戏吧

然后都可以试着把这个呃这个差值给关掉

然后再打开对吧

然后比较一下效果对吧

然后呃那这里就先说到这儿

马上再给大家继续这个话题啊

我们把 3d 应用差值就这么说完了好

那么三线性差值得到的结果是什么

### 01:00:18,16

![01-00-18](tmp/01-00-18.jpg)

那太漂亮了

对不对

就像这里大家可以看到哦

这里原本说是黑了一片对吧

这里黑的和红的有了一个过度了对吧

然后就是说这个在不同的区域

比如这里黄的和绿的有一个过渡了

这里就是说不同的区域

它就确实有了一个这个不同的这个这个这个有一个连续变化的结果

当然大家会注意到柱子上有些问题啊

这是几何本身的问题

这个咱们暂时不说啊

就是说这个就是基本上来说通过三线性差值

我就可以知道它在哪一层差呢

在某一个浮点型的连续的一个书上差好

那这就是这个 mp 好

那么大家可以看到 me map 效果挺好的

### 01:00:53,36

![01-00-53](tmp/01-00-53.jpg)

可是 me map 是否真能完全解决问题

这是一个我们要思考的事情对吧

然后我们可以看一看这个

### 01:01:01,46

![01-01-01](tmp/01-01-01.jpg)

比如说我们认为哈

如果一个像素我用这个 512 个这个这个采样点应该已经够了

那么咱们假设这个是一个准确的结果

就是说假设这个 512 倍的这个这个超采样

能够给我们准确的结果啊

也差不多

这如果是准确的

那如果咱们看 mile map

我们就会看到有区别什么呢

我们可以看大家可以看到这里发现 mmap 啊

不太对

mei map 到了远处的地方

他会把所有的细节什么东西全部都给糊掉

大家会发现这么一个问题

对不对

会发现这么一个一个一个一个情况

在远处出现了

这个我完完全全不应该糊掉的东西

然后这种我们就管它叫 over ber

很简单模糊的过分了对吧

over 不乐

然后为什么会出现这种情况对吧

这就是我们要思考的问题

那么从什么地方可以来解解决这个问题呢

那就是说如果 mmap 是对的

那一定不会有这个问题

那他肯定哪儿不对

那不对

在哪儿

其实咱们一开始已经说过了对吧

我说它首先它只能查询一个方块的区域内

然后然后就是正方形区域内它的这个范围查询它的平均值对吧

那那那如果不是

那就没办法对吧

然后它这个其他各种各样的近似涉及到它三线性差值本身

它也是近似差值嘛对吧

毕竟不是说真正能算出来对吧

那咱们就先从这个方块的这个查询这个这个上面来说好吧

然后然后我们提到 mmap 会有这么一个问题

### 01:02:23,6

![01-02-23](tmp/01-02-23.jpg)

咱们马上再具体分析

但是有一个办法可以解决部分解决啊

部分解决这个呃这个三线性差值所产生的问题

那么是用什么是什么办法来解决呢

这个东西叫做各项异性过滤

这个我相信大家这个要是打游戏打的多

估计也接触过对吧

这个各项异性过滤它的效果会比三线性差值要好

然后再从这个例子上也可以明显的看出来对吧

远处的话已经明显可以看到细节了

不是完全糊掉的

那么这是怎么回事呢

那咱们分析一下啊

### 01:02:52,3

![01-02-52](tmp/01-02-52.jpg)

就是说啊 mmp map 本身他做了一个什么事情

他做了这么一个事情

就是说啊给你一个原始的一张图

然后你把它长宽各缩小一半

缩小一半

缩小一半

也就是说啊反映在这么一张图上

大家可以看到 mile map 计算的其实是这个对角线上的这么一些图片

然后呢就是有一些图就是说我这个长宽我不同的这个长宽比

做这个预计算诶

这个是弥补 map 没有的

比如说像这里还是这么一个卫星的这个图啊

大家可以看到这个沿着这个水平方向

第一行大家可以看到这个这个图是这么回事

它的竖直方向没有发生这个长度变化

只是水平方向被压缩了一下

哎然后这个每一行其实都是这么做的

大家看每一行都是水平方向

如果我看每一列的话

那就是每一列的话

它宽度都不变

它的高度会发生变化

也就是说它比这个 mp map 的结构要多了一些东西

多的是什么呢

那么我这里问一个这个事情

就比如说啊在这这一幅图上

大家可以看到它已经被这个这个数值方面压缩的非常厉害了

那在这张图的一个像素上

如果我把它给回到这个这个原始的一张图上

就说这个图上的一张像素

这个第三张图它的一个像素对应到原始图上是一个什么区域呢

大家可以想象得到是一个这个数值的拉伸了的区域对吧

也就是说是一个矩形的区域

然后也就是说通过我们这样一种方式的预计算

我就可以查询任何一个被压扁了的图

任何一个位置我可以查到原始的对应到原始的图上的一个矩形的区域

而不用限制在一个正方形区域上

诶这样的话那效果就不错嗯

那为什么会这样呢

### 01:04:31,70

![01-04-31](tmp/01-04-31.jpg)

是因为我们看这里这里像素上面的任何一

也就就是说唉屏幕上面有一个像素映射到这个纹理上

可不一定都是一个规律的形状

很有可能会出现这种超级斜着的这种这种气的啊

这些地方对不对

那就非常不好对吧

那那这这种情况下

我要把它近似成一个框

那还得了

咱们把这个框给框起来

你会发现哦

那我可不是求了一个更大的区域的平均嘛

也就是说这就会造成 over blog

对不对

那也就是说如果我们引入了各项异性过滤的话

对于这种结果

对于这种基本长条形的这种这种问题就可以得到一个完美的解决

就是说这个各项异性过滤

允许我们对这个长条形的这种区域做一个快速的范围查询

也不用限制在一个这个正方形区域内了

那自然得到的结果就会好很多

那么大家就会问了

那各项异性过滤

我对于这个生成的这这这些新的图啊

任意一个像素它都对应了一个矩形区域

那倘若的我的我的查询范围查询真的特别坑

就像这样

它它它是一个斜着的一个区域

那你说你要拿一个这个矩形区域去框

它也不是特别好

对不对

也就是说各项异性过滤仍然没能解决问题对吧

各各项异性过滤咱们咱们总结一下啊

解决了一部分问题

对于矩形的查询可以可以得到一个更准确的结果

比这个正方形的 mmap 差距要好

但是对于斜着的这种区域不行

没有办法

那怎么办呢

人们就发明了一些这个另外的一些方法

### 01:06:01,40

![01-06-01](tmp/01-06-01.jpg)

这些这个给给大家举一个例子

这里叫做 e w a 这个过滤 e wa 过滤是什么意思呢

其实很简单

你有一个任意的不规则的形状

不规则的形状

它都可以把它给拆成这个这个很多不同的原型去覆盖这个不规则形状

比如像这里它是一个这个这个这个一个椭圆吧

它可以把它拆成比如说三个不同的圆形去覆盖这个椭圆

然后每一次我就去查询一个圆形

然后我多次查询

我自然就可以去覆盖这么一个这个不规则的形状

那当然可以

但是造成代价是什么呢

大家可以已经听出来了

对不对

多次查询嘛对吧

你查询肯定是要耗时的嘛对吧

所以说这个又一次大家体验到这个事情质量越好

代价越大一定对

然后呢咱们回到刚才我说的这个各项异性过滤啥啊

各项异性过滤它本身生成了这些这个这个呃那么多其他的图啊

然后对于这个图来说

大家可以利用刚才 mp map 的分析方法

大家可以看到

如果我要生成各项异性过滤的这个这个呃

那么些中间的这些这些图啊

压扁的这些图啊

然后总共的开销是原本的三倍

大家可以看到原本的这个开销是左上角嘛

现在这个总共的开销变成了原来的三倍

大家对比一下 mp map map map 呢只是开销只是原本的 1/3 额外的开销啊

然后这就是这个代价对吧

然后当然了

各项异性过滤就是这种水平数值压扁的

它本身还有名字叫 rap map 生成的这个东西

当然平常大家这个很少提这个概念

但是没有关系

就反正就是说这就是这个各项异性过滤的这个这个呃概念

当然这里多说一句

什么叫各项异性

各项异性就是说在不同的方向上

它的这个表现各不相同啊

就是说我们原本认为这个这个矩形它的水平和数值上的表现完全相同

这种就叫各项同性

但是如果有同学硬要说

比如在各个方向上

它一个矩形它还是不一样的

对吧

呃确实是这样

但是基本上还是我们认为呢是各项同性的

然后这个呢就是各项异性就是指这个意思

他可以考虑不同的所谓方向性

就这个意思好吧

也就是说通过这种方式

然后我们就可以把这个这个嗯最后的结果给给给做得更好好吧

然后这一块就是整个的这个呃 me map 这块涉及的问题

### 01:08:11,90

![01-08-11](tmp/01-08-11.jpg)

然后呢我觉得唉呀好吧

这里这里要不这样吧

要不这样吧

这个纹理这块呢

我觉得我留到留到下节课再给大家说吧

然后就是说文里还有一些其他的这些应用

### 01:08:23,26

![01-08-23](tmp/01-08-23.jpg)

然后这些应该花不了太多时间

然后这里在多说一句

给大家说完这个这个各项异性过滤吧

就更加异性过滤

大家如果打游戏的话

还会接触到一个概念多少 x 对吧

那其实意思就是说你计算多少层

比如说这个这个 2x 各项异性过滤就基本上计算到这儿

就是只是方向上这个压缩了一次

你会看到这左上角的这么一个区域啊

呃这个区域我现在鼠标框的这个区域

左上角 2x2 的图的区域

然后如果说是 4x 呢

它就是就是说在这个竖直方向上又压缩了一倍

压缩到这里会形成这水平方向上也是一样

生成这么一个区域

左上角啊

然后这个 8x 16 x 一样

大家会发现这个随着这多少 x 逐渐往上增加

这个最后的结果会逐渐收敛到总存储的三倍

也就是说各项异性过滤它的存储量

其实来说你开多少 x 这个其实关系不大

这也就是为什么说这个用应用各项异性过滤

只要你的显卡显存足够

这里和计算力基本没有关系啊

就是显存足够的话

这个尽量都开各项异性过滤

开到最高就好了

这个对这个对对对

就比如打游戏

它们的性能几乎不会有任何影响啊

他这个只是对显存的这个开销有一点这个这个要求而已

其实也没有多少对吧

多那么一点点好

那那这里呢就是就是说这个这个啊差不多就到这儿吧

今天然后咱们这个下节课

我们再把这个剩下的这个纹理的高级应用说明白

然后再有空在这个继续说这个啊这个这个这个这个啊阴影

如果说嗯不这么安排的话

那咱们就开始进行下一个环节了

就是几何了

也就是说到此为止啊

咱们可以简单做一个总结

到目前为止

除了阴影这块的技术没有说以外

整个的光栅化的一个过程

基本上咱们都已经涵盖到了

就是说整个硬件上在做什么

然后就是说同行

现在现在大家这个在这个编程这个这个这个啊实时的这个渲染的项目

然后再做哪些内容

基本上来说就都在这儿了好吧

然后咱们课程总共大家这会注意到是四块

然后咱们很快就要进入第二话

开始说几何好吧

然后那这个呃今天就说到这儿

这个背后呢就给大家解释了好多这个这个这个背后的原理

但是这应该不需要说这么细啊

大家这个能理解

那是最好理解不了

没有什么关系

好吧啊

这个这个这个那就那我们今天就说到这儿

然后如果大家有什么其他问题的话

这个我看到大家确实有问题啊

今天可能不太来得及

然后这个呃有问题大家就欢迎到这个 bbs 上多问好吧

我有时间我也看一下

然后我也这个督促一下助教同学们多给大家回答问题

好

那咱们今天就说到这儿

然后我们把时间在这个教会给技术秘书同学

然后各位同学感谢大家支持

咱们这个下节课再见啊

拜拜

### 01:11:15,3

![01-11-15](tmp/01-11-15.jpg)
