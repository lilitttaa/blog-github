---
title: C++ Primer 9. 顺序容器
---

## 容器概述

- 所有容器类都共享公共的接口，不同容器按不同方式对其进行扩展。
- 每种容器都提供了不同的性能和功能的权衡。
- 现代 C++ 程序应该使用标准库容器，而不是更原始的数据结构,如内置数组。
- 通常容器定义的头文件与容器类名相同，如 vector 定义在头文件 vector 中。

## 顺序容器概述

顺序容器类型如下:
![Alt text](image.png)

如何选择容器类型:

- 除非有特殊需求，应该使用 vector。
- 如果小元素很多，且在意内存开销，则尽量不要使用 list 和 forward_list。
- 要求随机访问，使用 vector 或 deque。
- 要求在中间插入或删除，使用 list 或 forward_list。
- 只在两端插入或删除，使用 deque。
- 可以在程序中只使用 vector 和 list 公共的操作：使用迭代器，不使用下标操作，避免随机访问。在必要时可以切换。
- 如果一定要在中间插入，又要随机访问，可能考虑先用 list，然后再转换为 vector。

## 容器库概览

容器操作分为三类：

1. 针对所有容器的操作。
2. 针对顺序/关联/无序容器的操作。
3. 针对某个特定容器的操作。

以下是针对所有容器的操作：
| 类型别名               | 说明                                      |
|------------------------|-----------------------------------------|
| iterator               | 此容器的迭代器类型                        |
| const_iterator         | 此容器的常量迭代器类型                    |
| reverse_iterator       | 逆向迭代器类型                            |
| const_reverse_iterator | 常量逆向迭代器类型                        |
| size_type              | 无符号整数类型，足以表示容器的最大可能大小 |
| value_type             | 容器保存的元素类型                        |
| difference_type        | 两个迭代器之间的距离                      |
| reference              | 与元素类型相同的引用类型                  |
| const_reference        | 与元素类型相同的常量引用类型              |

| 构造函数      | 说明                               |
|---------------|----------------------------------|
| C c;          | 默认构造函数，创建一个空容器        |
| C c(c2);      | 构造 c2 的拷贝 c1                  |
| C c(b, e);    | c 是迭代器 b 和 e 定义的元素的副本 |
| C c{a, b, c}; | 列表初始化 c                       |

| 赋值与 swap     | 说明                                     |
|-----------------|----------------------------------------|
| c1 = c2;        | 将 c2 的拷贝赋给 c1                      |
| c1 = {a, b, c}; | 将列表初始化的元素赋给 c1，不适用于 array |
| c1.swap(c2);    | 交换 c1 和 c2 的内容                     |
| swap(c1, c2);   | 交换 c1 和 c2 的内容                     |

| 大小与容量    | 说明                              |
|---------------|---------------------------------|
| c.size();     | 返回 c 中元素的数目               |
| c.max_size(); | 返回 c 可以容纳的元素数目的最大值 |
| c.empty();    | 如果 c 为空，则返回 true           |

| 添加删除元素（除 array 外） | 说明                           |
|---------------------------|------------------------------|
| c.insert(args);           | 将 args 拷贝进 c 中            |
| c.emplace(inits);         | 使用 inits 构造 c 中的一个元素 |
| c.erase(args);            | 删除 args 指定的元素           |
| c.clear();                | 删除 c 中所有元素，返回 void    |

| 关系运算符   | 说明                                            |
|--------------|-----------------------------------------------|
| c1 == c2     | 如果 c1 和 c2 的所有元素相等，则返回 true        |
| c1 != c2     | 存在不相等的元素，或长度不同，则返回 true         |
| <, >, <=, >= | 依次比较 c1 和 c2 中的元素，直到找到不相等的元素 |

| 获取迭代器   | 说明                                          |
|--------------|---------------------------------------------|
| c.begin();   | 返回指向 c 中第一个元素的迭代器               |
| c.end();     | 返回指向 c 中尾元素的下一个位置的迭代器       |
| c.cbegin();  | 返回指向 c 中第一个元素的常量迭代器           |
| c.cend();    | 返回指向 c 中尾元素的下一个位置的常量迭代器   |
| c.rbegin();  | 返回指向 c 中尾元素的逆向迭代器               |
| c.rend();    | 返回指向 c 中首元素上一个位置的逆向迭代器     |
| c.crbegin(); | 返回指向 c 中尾元素的常量逆向迭代器           |
| c.crend();   | 返回指向 c 中首元素上一个位置的常量逆向迭代器 |

### 迭代器

- forward_list 不支持逆向迭代器和 --运算符。
- 迭代器的范围是左闭右开的，即 [begin, end)。

```cpp
whlie (begin != end) {
	*begin = val;
	++begin;
}
vector<int> v{1,2,3,4};
vector<int>::iterator rb =

```

## 顺序容器操作

- 顺序容器可以保存几乎任何类型，但某些容器操作对元素类型有其自己的特殊要求。可以为这些类型定义容器，但只能使用那些没有特殊要求的容器操作。

```cpp
// noDefault 是一个没有默认构造函数的类
vector<noDefault> v1(10, init); // 正确：提供了初始化器
vector<noDefault> v2(10); // 错误
```

## vector 对象是如何增长的

## 额外的 string 操作

## 容器适配器

- 适配器（ adaptor）是一种机制，能使某种事物的行为看起来像另外一种事物一样。
- 容器、迭代器和函数都有适配器。
- 容器适配器接受一种已有的容器类型，使其行为看起来像一种不同的类型。

所有容器适配器都支持的操作和类型：
| 名字                 | 说明                                          |
|----------------------|---------------------------------------------|
| size_type            | 无符号整数类型，足以保存当前对象的最大可能大小 |
| value_type           | 元素类型                                      |
| container_type       | 适配器使用的基础容器类型                      |
| A a;                 | 创建一个名为 a 的空适配器                     |
| A a(c);              | 创建适配器 a，带有容器 c 的拷贝                |
| ==, !=, <, <=, >, >= | 返回容器的比较结果                            |
| a.empty();           | 如果适配器为空，则返回 true                    |
| a.size();            | 返回适配器中元素的数目                        |
| a.swap(b);           | 交换 a 和 b 的内容                            |
| swap(a, b);          | 交换 a 和 b 的内容                            |

顺序容器适配器：
| 名字           | 说明                                                               | 头文件 |
|----------------|------------------------------------------------------------------|--------|
| stack          | 默认容器为 deque，也可以用 list、vector 不支持 forward_list 和 array | stack  |
| queue          | 默认容器为 deque，也可以用 list 不支持 vector、forward_list 和 array | queue  |
| priority_queue | 默认容器为 vector，也可以用 deque 不支持 list、forward_list 和 array | queue  |
